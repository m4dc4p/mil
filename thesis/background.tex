\documentclass[12pt]{report}
%include polycode.fmt
\include{preamble}
\begin{document}
\include{document.preamble}

\chapter{Background}

%% A short section giving the history of dataflow optimization techniques
%% and basic concepts.

% Describe dataflow analysis in general terms and defines key
% concepts: basic blocks, control flow, facts, and
% rewrites. Bind/Return elimination is used as an an example.

\section{Dataflow Optimization}

\citet{SoAndSo} first described dataflow
analysis. It works by transforming a \emph{control-flow graph} (CFG)
representation of the program. This section introduces the concepts
necessary to understand how dataflow optimization works and describes
how the technique is usually implemented.

\subsection{Basic Blocks and Control-Flow Graphs}

A dataflow optimization operates over a ``control-flow graph'' (CFG)
of the program -- a directed graph where edges encode branches or
jumps and nodes represent statements. Programs run by entering a node
from a predecessor, executing the statements in turn, and exiting the
node to a successor. Multiple successors imply a conditional branch,
though the program can only choose one. A special ``entry'' node, with
no predecssors, exists to give the program a starting point.

The statements in each node must define a ``basic block,'' which means
there can only be one entry and one exit to the node. Each 
predeccessor starts at the same statement; execution cannot start in
the ``middle'' of the statements in the node. Each successor also
leaves from the same instruction, so only one ``branch'' can exist in
each node.

For example, consider the ``fall-through'' implied by the use of #case#
statements in this C-language program fragment:

\begin{verbatim}
  switch(i) {
  case 1:
    printf("1");
    break;
  case 2:
    printf("2");
  case 3:
    printf("3");
  }
\end{verbatim}

\begin{figure}[h]
\begin{verbatim}
   A
  switch   ----<-
  | |  |  |      |
  | |  |  v C    ^
  | |   ->case 3 |
  | |     |      |
  | |      ->----_-- 
  | | B          |  |
  |  ->case 2 ->-   v
  |                 |
  |   D       ----<-
   ->case 1  |
     |       v
     v       |
   --+-----<-      
  |  
   -> ...
\end{verbatim}
\caption{CFG illustrating \emph{fall-through} allowed by the
  C-language \texttt{switch} statement.}
\label{switchCfgEg}
\end{figure}

Figure \ref{switchCfgEg} shows a CFG for this fragment. Execution
begins at node A. Node C has two predeccessors: A and B. The edge
between Node B and C represents fall-through from the second to third
case. They cannot be combined because the node would need two distinct
entry points. Encoding a program into basic blocks usually involves
inserting similar branches. The CFG makes explicit control--flow that
exists by implication in the source program.

\subsection{Direction, Facts and Rewrites}

\subsection{Example: Bind/Return Collapse}

Dataflow optimizations transform the CFG representation of a program,
with the goal of making a faster (or smaller, or more efficient, etc.)
program. Dataflow computes a set of ``entry'' assumptions and ``exit''
facts for each node in the graph. Facts for one node become
assumptions for the nodes' successors (thus the term
``dataflow''). The algorithm iteratves over the entire graph until a
fixed point is reached -- that is, facts and assumptions no longer
change. The computed facts can then be used to transform the graph.

\emph{Constant propagation example -- or something more functional?}

\emph{Introduce forward and backwards dataflow.}

% What does dataflow mean?

% How do you use it? 

% Example

\end{document}
