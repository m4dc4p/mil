\documentclass[11pt]{article}
\usepackage{standalone}
%include polycode.fmt
\usepackage{sectsty}
\usepackage{palatino}
\usepackage[scaled=0.92]{helvet}
\usepackage{xspace}
\renewcommand\ttdefault{cmtt}
\allsectionsfont{\sffamily}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage{setspace}
\usepackage{cmds}
\usepackage{ifthen}
\newboolean{lhs2tex}
\setboolean{lhs2tex}{true}
% Awkward Habit: Design and Optimization of A Monadic Intermediate Language
% \title{Dataflow Optimization of a Monadic Intermediate Language using Hoopl}
\title{Optimizing Monadic Programs using Hoopl}
%if False
\setboolean{lhs2tex}{false}
\author{Justin Bailey \\ \url{justinb@cs.pdx.edu}}
%else
\ifthenelse{\boolean{lhs2tex}}{\author{Justin Bailey \\ \url{justinb@@cs.pdx.edu}}}{}
%endif
\date{\today}

\begin{document}
\VerbatimFootnotes
\DefineShortVerb{\#}
\doublespacing

\maketitle

\section{Abstract}

This thesis describes a monadic intermediate language and how we used
the Hoopl library to implement optimizations for programs written in
it. We show that our monadic language makes it simpler to implement
optimizations, such as Lazy Code Motion, not normally applied to
functional languages. We also demonstrate an optimization that can
eliminate many intra- and inter-procedure closure allocations and
several optimizations based on the \emph{monad laws}.

\section{Audience}

\section{Introduction/Overview}

\section{Background}
\subsection{Dataflow Optimization}

\citet{SoAndSo}\comment{Gary Kindal?} first defined dataflow
optimization techniques. They operate by transforming a
\emph{control-flow graph} (CFG) representation of a program. This
section introduces the concepts necessary to understand how dataflow
optimization works, and describes how the technique is usually
implemented.

%% A short section giving the history of dataflow optimization techniques
%% and basic concepts.

\subsubsection{Basic Blocks and Control--Flow Graphs}

A dataflow optimization operates over a ``control-flow graph'' (CFG)
of the program -- a directed graph where edges encode branches or
jumps and nodes represent statements. Programs run by entering a node
from a predecessor, executing the statements in turn, and exiting the
node to a successor. Multiple successors imply a conditional branch,
though the program can only choose one. A special ``entry'' node, with
no predecssors, exists to give the program a starting point.

The statements in each node must define a ``basic block,'' which means
there can only be one entry and one exit to the node. Each 
predeccessor starts at the same statement; execution cannot start in
the ``middle'' of the statements in the node. Each successor also
leaves from the same instruction, so only one ``branch'' can exist in
each node.

For example, consider the ``fall-through'' implied by the use of case
statements in this C language program fragment:

\begin{verbatim}
  switch(i) {
  case 1:
    printf("1");
    break;
  case 2:
    printf("2");
  case 3:
    printf("3");
  }

  printf("4");
\end{verbatim}

\begin{verbatim}
   A
  switch   ----<-
  | |  |  |      |
  | |  |  v C    ^
  | |   ->case 3 |
  | |     |      |
  | |      ->----_-- 
  | | B          |  |
  |  ->case 2 ->-   v
  |                 |
  |   D       ----<-
   ->case 1  |
     |       v
     v       |
   --------<-      
  |  E
   ->printf("3")
\end{verbatim}

Figure \ref{switchCfgEg} shows a CFG for this fragment. Execution
begins at node A. Node C has two predeccessors: A and B. The edge
between Node B and C represents fall-through from the second to third
case. They cannot be combined because the node would need two distinct
entry points. Encoding a program into basic blocks usually involves
inserting similar branches. The CFG makes explicit control--flow that
exists by implication in the source program.

\subsubsection{Dataflow over CFGs}

Dataflow optimizations transform the CFG representation of a program,
with the goal of making a faster (or smaller, or more efficient, etc.)
program. Dataflow computes a set of ``entry'' assumptions and ``exit''
facts for each node in the graph. Facts for one node become
assumptions for the nodes' successors (thus the term
``dataflow''). The algorithm operate over the entire graph until a
fixed point is reached -- that is, facts and assumptions no longer
change. The computed facts can then be used to transform the graph.

\emph{Constant propagation example -- or something more functional?}

\emph{Introduce forward and backwards dataflow.}

% What does dataflow mean?

% How do you use it? 

% Example

\subsection{Monadic Languages}

Introduce what a ``monadic'' language looks like and the advantages such a form
gives us.

\section{The Hoopl Library}

Explains the purpose of the Hoopl library and basic concepts (nodes,
graphs, rewrites and transfers)

\section{BC -- The Language of Blocks and Captures}

Defines, motivates and gives examples of the BC language.

\section{Compiling the \lamA to BC}

Demonstrates compiliation from a variant of the \lamA to BC. 

\section{Dataflow Optimization and the Hoopl Library}

Describes Hoopl and its use.

\section{Optimizing BC Programs Using Hoopl}

Catalog of optimizations implemented over BC using Hoopl.

\section{Eliminating Heap Allocation in BC using Hoopl}

Special attention to an optimization for eliminating heap allocation
in BC programs.

\section{Compiling Habit to BC to x86}

How it all came together.

\section{Conclusion \& Future Work}

\end{document}
