\documentclass[11pt]{article}
\usepackage{standalone}
\usepackage{comment}
%include polycode.fmt
\usepackage{sectsty}
\usepackage{palatino}
\usepackage[scaled=0.92]{helvet}
\usepackage{xspace}
\usepackage{verbatim}
\renewcommand\ttdefault{cmtt}
\allsectionsfont{\sffamily}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage{setspace}
\usepackage{cmds}
\usepackage{ifthen}
\newboolean{lhs2tex}
\setboolean{lhs2tex}{true}
% Awkward Habit: Design and Optimization of A Monadic Intermediate Language
% \title{Dataflow Optimization of a Monadic Intermediate Language using Hoopl}
\title{Using Dataflow Optimization Techniques with a Monadic Intermediate Language}
%if False
\setboolean{lhs2tex}{false}
\author{Justin Bailey \\ \url{justinb@cs.pdx.edu}}
%else
\ifthenelse{\boolean{lhs2tex}}{\author{Justin Bailey \\ \url{justinb@@cs.pdx.edu}}}{}
%endif
\date{\today}

\begin{document}
\VerbatimFootnotes
\DefineShortVerb{\#}
\doublespacing

\maketitle

\begin{abstract}
  Dataflow analysis underlies many optimizations implemented by
  compilers for imperative languages. Functional languages implement
  many of the same optimizations using algebraic
  rewriting. Traditional intermediate representations for functional
  languages make the implementation of optimizations using dataflow
  analysis awkward and difficult. We show that, by chosing a monadic
  representation, we are able to implement several optimizations using
  dataflow analysis straightforwardly. We demonstrate several common
  optimizations, such as constant propagation and dead-code
  elimination. We implement an optimization which eliminates
  intermediate closure construction, essential to the performance of
  any functional program. Finally, we implement one of the most
  complicated dataflow-based optimizations, \emph{Lazy Code
    Motion}. To our knowledge this is the first time it has been
  implemented in a functional language compiler over a monadic
  intermediate language. Our work uses the Hoopl library to implement
  our optimizations and thus also serves as a case-study for advanced
  uses of that library.
\end{abstract}

\section{Introduction/Overview}

Compilers for imperitave languages implement many optimizations using
\emph{dataflow analysis}. This method treats the program as a graph,
where edges represent execution paths and nodes represent statements
in the program. Dataflow analysis computes facts about each node and
then transforms the graph into an equivalent, yet faster (or smaller,
or more efficient, etc.) program. Optimizations which use dataflow
analysis include constant propagation, dead-code elimination,
common-subexpression elimination and many others.

Dataflow analysis on imperitave programs arises naturally due to the
explicit flow-of-control from statement to statement. For pure
functional languages, with flow-of-control determined by evaluation
order, the fit seems more awkward. However, call-by-value, pure,
\emph{monadic} functional programs embody the best of both
styles: expression-based evaluation \emph{and} explicit
control-flow. 

Our work, then, defines a monadic language and optimizes programs in
it using dataflow analysis. We implement a number of optimizations
common to imperitave and functional languages, including constant
propagation and dead-code elimination. We implement an optimization
which eliminates intermediate closure construction, showing that this
technique can be used for optimizations specific to functional
languages. Finally, we implement \emph{lazy code motion}, which to our
knowledge has not been applied to programs in a monadic language
before.

We use the Hoopl library\rem{reference} to implement our
optimizations. Besides showing that it is possible (and even
desirable) to use dataflow analysis in this context, our work also
serves as a case-study for advanced uses of Hoopl.

\section{Background}

%% A short section giving the history of dataflow optimization techniques
%% and basic concepts.

% Describe dataflow analysis in general terms and defines key
% concepts: basic blocks, control flow, facts, and
% rewrites. Bind/Return elimination is used as an an example.

\subsection{Dataflow Optimization}

\citet{SoAndSo} first described dataflow
analysis. It works by transforming a \emph{control-flow graph} (CFG)
representation of the program. This section introduces the concepts
necessary to understand how dataflow optimization works and describes
how the technique is usually implemented.

\subsubsection{Basic Blocks and Control-Flow Graphs}

A dataflow optimization operates over a ``control-flow graph'' (CFG)
of the program -- a directed graph where edges encode branches or
jumps and nodes represent statements. Programs run by entering a node
from a predecessor, executing the statements in turn, and exiting the
node to a successor. Multiple successors imply a conditional branch,
though the program can only choose one. A special ``entry'' node, with
no predecssors, exists to give the program a starting point.

The statements in each node must define a ``basic block,'' which means
there can only be one entry and one exit to the node. Each 
predeccessor starts at the same statement; execution cannot start in
the ``middle'' of the statements in the node. Each successor also
leaves from the same instruction, so only one ``branch'' can exist in
each node.

For example, consider the ``fall-through'' implied by the use of #case#
statements in this C-language program fragment:

\begin{verbatim}
  switch(i) {
  case 1:
    printf("1");
    break;
  case 2:
    printf("2");
  case 3:
    printf("3");
  }
\end{verbatim}

\SaveVerb{switch}#switch#

\begin{figure}[h]
\begin{verbatim}
   A
  switch   ----<-
  | |  |  |      |
  | |  |  v C    ^
  | |   ->case 3 |
  | |     |      |
  | |      ->----_-- 
  | | B          |  |
  |  ->case 2 ->-   v
  |                 |
  |   D       ----<-
   ->case 1  |
     |       v
     v       |
   --+-----<-      
  |  
   -> ...
\end{verbatim}
\caption{CFG illustrating \emph{fall-through} allowed by the
  C-language \texttt{switch} statement.}
\label{switchCfgEg}
\end{figure}

Figure \ref{switchCfgEg} shows a CFG for this fragment. Execution
begins at node A. Node C has two predeccessors: A and B. The edge
between Node B and C represents fall-through from the second to third
case. They cannot be combined because the node would need two distinct
entry points. Encoding a program into basic blocks usually involves
inserting similar branches. The CFG makes explicit control--flow that
exists by implication in the source program.

\subsubsection{Direction, Facts and Rewrites}

\subsubsection{Example: Bind/Return Collapse}

Dataflow optimizations transform the CFG representation of a program,
with the goal of making a faster (or smaller, or more efficient, etc.)
program. Dataflow computes a set of ``entry'' assumptions and ``exit''
facts for each node in the graph. Facts for one node become
assumptions for the nodes' successors (thus the term
``dataflow''). The algorithm iteratves over the entire graph until a
fixed point is reached -- that is, facts and assumptions no longer
change. The computed facts can then be used to transform the graph.

\emph{Constant propagation example -- or something more functional?}

\emph{Introduce forward and backwards dataflow.}

% What does dataflow mean?

% How do you use it? 

% Example

\section{The Hoopl Library}

\emph{Introduce the Hoopl library, describing how
it approaches dataflow analysis. Important concepts
such as shape, transfer and rewrite functions, facts and
lattices will be described. }

\section{Languages}

\emph{Defines the languages used in the thesis and a simple
  compilation scheme from a \lamA variant to our monadic language. }

\subsection{Source Language}

\emph{Defines a \lamA variant with some monadic effects, enough to
  illustrate interesting programs.}

\subsection{Monadic Intermediate Language}

\emph{Defines our monadic language and explains the terms in
  it. Example programs are given which illustrate closure construction
  and data allocation. The use of ``tail'' vs. statements is motivated
  and described. }

\subsection{Compiling to Our MIL}
\emph{A compilation scheme which uses Hoopls ``shapes'' is
described. This scheme will give use our initial, unoptimized
MIL program. An example (possibly |compose|, or |const3|) illustrates 
our scheme.}

\section{``Traditional'' Optimizations}

\emph{The bulk of our work. Each optimization implemented is
  described. Each subsection should follow a common recipe: describe
  the optimization, give an example program and show how we want it
  changed, show salient points about the optimization (with code
  snippets and references to the full library), and reflect on the
  implementation.  Lazy Code Motion may get its own section.}

\emph{One question: should optimizations be categorized by direction? We could
describe all forward optimizations, then all backward ones. That may help
set up the concepts necessary to describe LCM.}

\subsection{Constant-Propagation}
\emph{This portion gives an overview of the optimization, without
code or (much) notation.}

\subsubsection{Example of Desired Optimization}
\emph{A program is given and we show what we'd like it to be
transformed to.}

\subsubsection{Implementation}
\emph{``Interesting'' pieces of the implementation are described.}

\subsubsection{Reflection}
\emph{What was good, what didn't work so well, and how Hoopl helped
or hindered the implementation}

\subsection{Dead-code elimination}
\subsubsection{Example of Desired Optimization}
\subsubsection{Implementation}
\subsubsection{Reflection}

\section{Monadic Optimizations}
\emph{Describes optimizations based on the monad laws: bind/return collapse and
  monadic fuzzbang (inlining)}

\subsection{Bind/Return Collapse}
\emph{Collapsing ``|x <- return y; p|'' to ``|[y/x] p|''.}
\subsubsection{Example of Desired Optimization}
\subsubsection{Implementation}
\subsubsection{Reflection}

\subsection{Monadic FuzzBang}
\emph{``FuzzBang'' --  monadic inlining. That is:}

> y <- (z <- x; p1)
> p2

\noindent
\emph{becomes:}

> z <- x
> y <- p1
> p2

\subsubsection{Example of Desired Optimization}
\subsubsection{Implementation}
\subsubsection{Reflection}

\section{Intermediate Closure Elimimation}
\emph{Describes our optimization for collapsing intermediate
closures. Our choice of representation is analyzed to
show how it facilitates this optimization. We should show one
closure can be eliminated from a program and how the optimization
is applied over and over until a fixed point is reached. The format
for this section will vary from the other two.}

\section{Implementing Lazy Code Motion}
\emph{Describes our implementation of LCM in terms of the four passes
  used. This section will give an overview of LCM and briefly describe
  each pass. We give a example program which will be used throughout
  the section.}

\subsection{Anticipated Expressions}

\subsection{Available Expressions}

\subsection{Dead-code Elimination}

\subsection{Reflection}

\emph{Conclusions regarding our implemenation.}

\section{Conclusion \& Future Work}

\emph{Where we started and where we wished we could have go to.}

\end{document}
