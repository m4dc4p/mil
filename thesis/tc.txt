Typechecking keeps track of the following:

  * A set of initialized registers.
  * The result type of the current block, which is the set of initialized
  registers when a return instruction is found.
  
Typechecking follows these rules:

  * A label has a set of initialized "entry" registers and a set of
  initialized "result" registers. When a label is the target of a
  branch or a jump, its "entry" set must be a subset of the initialized
  registers in the current environment. The target label's result
  type must match the result type of the current block.

  * A return instruction sets the result type of the current block to
  the current set of initialized registers.

  * movl sets the type of a given register, from uninitialized to
  initialized.

Open questions:

  * How to deal with memory references?
  * How to get richer types besides initialized and uninitialized? 

Example below shows an iterative approach to typechecking a small
set of machine code. The result and "current" register sets are
shown next to each instruction. Capital letters represent unknown
sets of registers. If a register appears in a column, it has initialized
type, otherwise it is assumed to be uninitalized.

Sequential blocks are connected by unconditional jumps, to allow
each block to be treated uniformly. Conditional branches have two
targets, one for success and the other for failure. The entry set 
for the labels can differ, but their result set must be the same.

We start by annotating the initialized registers added to the
"current" environment by each instruction. The result set
is not known yet so we put placeholders (A, B, C) in
that column.

Instructions       Result Set  Current Registers
------------       ----------- -----------------
start:
 movl $a, edi      A           edi
 movl $n, ecx      A           ecx, edi
 jmp loop          A           ...

loop:
 movl $0, %(edi)   B           edi
 addl $4, edi      B           edi
 decl ecx          B           ecx, edi
 jnz loop end      B           ...

end:
 return            C           C
 
Registers which are used by not initialized in a block become the type
of the block's label. We show the annotation next to each label and
update label types accordingly. Only "loop" is interesting:

Instructions       Result Type Register Types
------------       ----------- --------------
start: X
 movl $a, edi      A           edi
 movl $n, ecx      A           ecx, edi
 jmp loop          A           ...

loop: {ecx, edi}
 movl $0, %(edi)   B           edi
 addl $4, edi      B           edi
 decl ecx          B           ecx, edi
 jnz loop end      B           ...

end: Y
 return            C           C

Each label also has a result type, which is determined by the result type
of the block. We use arrow notation to show the result type on each
label:

Instructions       Result Type Register Types
------------       ----------- --------------
start: X -> A
 movl $a, edi      A           edi
 movl $n, ecx      A           ecx, edi
 jmp loop          A           ...

loop: {ecx, edi} -> B
 movl $0, %(edi)   B           edi
 addl $4, edi      B           edi
 decl ecx          B           ecx, edi
 jnz loop end      B           ...

end: Y -> C
 return            C           C

Only the "return" instruction creates a concrete result type, by
copying its register types to the result types. Some sort of
constraint solving would show that B = {ecx, edi}, A = B and Y = C,
giving us the following annotations:

Instructions       Result Type Register Types
------------       ----------- --------------
start: X -> {ecx, edi}
 movl $a, edi      {ecx, edi}  edi
 movl $n, ecx      {ecx, edi}  ecx, edi
 jmp loop          {ecx, edi}  ...

loop: {ecx, edi} -> {ecx, edi}
 movl $0, %(edi)   {ecx, edi}  edi
 addl $4, edi      {ecx, edi}  edi
 decl ecx          {ecx, edi}  ecx, edi
 jnz loop end      {ecx, edi}  ...

end: C -> C
 return            C           C

