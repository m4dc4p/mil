%&preamble
\input{nodocclass}\dodocclass
\begin{document}
\makeatletter
\newcommand{\showfont}{encoding: \f@encoding{},
  family: \f@family{},
  series: \f@series{},
  shape: \f@shape{},
  size: \f@size{}
}\newtoks\fonttoks
\makeatother
\pagestyle{plain}
\input{document.preamble}

\noindent Uncurrying across blocks (as opposed to within a block) requires that
we rewrite block arguments.  A closure created in one block and used
in another carries an environment with it.  To ``unwrap'' the closure
in the second block requires that we also pass the correct environment
to the block.

We define ``global uncurrying'' as a forwards dataflow analysis problem.
We wish to determine, for each block, which of its arguments receive
closures and if that closure always points to the same destination. Once we 
determine that a given argument always refers to a particular \cc block, we can rewrite
any applications of that argument to the value that would be returned by 
the closure-capturing block referred to by the closure.

Our analysis will attempt to compute a known value for each argument to each 
ordinary block. Our facts will be values from the set $\textsc{Blocks}
\times \textsc{ArgPos} \times \textsc{Val}$, where \textsc{Blocks},
\textsc{ArgPos} and \textsc{Val} are defined as follows:
$$
\begin{array}{rlr}
  \textsc{Blocks} &= \{\lab b1/, \lab b2/, \dots, \lab bn/\} & \text{\it All ordinary blocks.} \\
  \textsc{ArgPos} &= \mathbb{N} & \text{\it Argument position in a block.} \\
  \textsc{Val} &= \{\lab k1/, \lab k2/, \dots, \lab kn/\} \cup \bot & \text{\it All \cc blocks and bottom.} \\
  \textsc{Facts} &= \textsc{Blocks} \times \textsc{ArgPos} \times \textsc{Val} 
\end{array}
$$

Not every value in \textsc{Facts} will be a useful value. In
particular, we will only want one tuple for each \textsc{Blocks}
$\times$ \textsc{ArgPos} combination. Further, each \textsc{Blocks}
$\times$ \textsc{ArgPos} value will only have \textsc{ArgPos} values up
to the number of arguments for the given block. 

The set \textsc{Val} denotes all \cc blocks in the program, plus a
$\bot$ value. The $\bot$ value will be used when we cannot determine if
a given block argument always refers to the same \cc block. When 
combining facts, we will want to combine facts that refer to the
same block and argument (i.e, their \textsc{Blocks} and \textsc{ArgPos} values
must agree). Therefore, we can define our meet operator, \lub, in terms of
\textsc{Val}, since \textsc{Blocks} and \textsc{ArgPos} will always be the same
for any two facts that we wish to combine. Our \lub operator will make
equal facts equal and set all other facts to $\bot$:
$$
  \begin{array}{rl}
    \lab k1/ \lub \lab k1/ &= \lab k1/ \\
    \lab k1/ \lub \lab k2/ &= \bot \\
    \lab k1/ \lub \bot &= \bot \\
    \bot \lub \bot &= \bot \\
  \end{array}
$$
\noindent Note that our definition of \lub is the same when arguments
are reversed (e.g., $\bot \lub \lab k1/ = \bot$).

Our transfer function determines if a given block ends by jumping to a
known block and if any of the arguments passed to the block are
closures with known destinations. The transfer function produces a set
of \textsc{Fact} values for each block. To produce this set, the transfer function
needs to track values within the block. A separate backwards analysis
will determine the final value of each argument used at the end of the
block. We do not detail that analysis here.

For each possible statement at end of a block, we detail the 
value produced by \mfun{transfer}. We use the notation $\mfun{val}(v)$ to indicate
the value associated with the variable $v$, as determined by the previously mentioned
separate analysis. We write \textsc{Fact} values as $(\textsc{Block},\textsc{ArgPos}, 
\textsc{Val})$ tuples:
$$
\begin{array}{rl}\allowdisplaybreaks[1]
  \mfun{transfer}(\return v/) &=  \emptyset \\
  \mfun{transfer}(\app v_1 * v_2/) &= \emptyset \\
  \mfun{transfer}(\invoke v/) &= \emptyset \\
  \mfun{transfer}(\goto b(v_1, \dots, v_n)) &= \{(\lab b/, 1, \mfun{val}(\var v_1/)), \dots, (\lab b/, n, \mfun{val}(\var v_n/))\}\\
  \mfun{transfer}(\prim p(v_1, \dots, v_n)) &= \emptyset \\
  \mfun{transfer}(\mkclo[k:v_1, \dots, v_n]) &= \emptyset \\
  \mfun{transfer}(\mkthunk[b:v_1, \dots, v_n]) &= \emptyset \\
  \mfun{transfer}(\ensurett{C\ v_1\ \dots\ v_n}) &= \emptyset \\
  \hspace{3in}\mathllap{\mfun{transfer}\left(\parbox{\widthof{\quad \alt C(b_1v_1\ \dots\ b_1v_n) -> \goto b1(b_1v_1, \dots, b_1v_n);}}{\baselineskip=12pt\disableparspacing;%%
        \case v;\endgraf%%
        \quad \alt C(b_1v_1\ \dots\ b_1v_n) -> \goto b1(b_1v_1, \dots, b_1v_n);\endgraf%%
        \quad $\dots$\endgraf%%
        \quad \alt C(b_nv_1\ \dots\ b_nv_n) -> \goto bn(b_nv_1, \dots, b_nv_n);%%
        }\right)} &= \left\{\parbox{\widthof{$(\lab b1/,1,\mfun{val}(\var b_1v_1/)), \dots, (\lab b1/,n,\mfun{val}(\var b_1v_n/)),$}}{%
    $(\lab b1/,1,\mfun{val}(\var b_1v_1/)), \dots, (\lab b1/,n,\mfun{val}(\var b_1v_n/)),\break
    \dots,\break
    (\lab bn/,1,\mfun{val}(\var b_nv_1/)), \dots, (\lab bn/,n,\mfun{val}(\var b_nv_n/))$}%
  \right\}
\end{array}
$$ 

\noindent The above combines the \milres case/ statement and \term tail/
expression into one, though they are different syntactic elements.

Once our analysis reaches a fixed point, each ordinary block in the
program will be associated with a \textsc{Fact} set. If a given
argument \var f/ to a block \lab b/ has a \mkclo[k:] value associated
with it in the set, meaning our analysis determined that \var f/
always receives a closure pointing to the same \cc block \lab k/, then we can
modify the arguments specified for \lab b/ so \lab b/ receives the
environment of the closure directly. That is, we ``unpack'' the
closure and pass its environment as arguments to \lab b/. Inside the
block, we can replace each application (i.e., \app f * g/) of the
argument with the result of the \cc block \lab k/. 

After we rewrite each block to take arguments as described above, we need to
rewrite all calls to those blocks to pass the additional arguments. 


\end{document}
