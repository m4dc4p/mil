------------------------------------------------------------------------
CS322 Languages and Compiler Design II                        Homework 2
------------------------------------------------------------------------

Grading Scheme:
---------------

Each of the 6 required programs in this assignment is worth up to 10
points, for a total of 60 points overall.  Program 7 is optional; I'm
happy if you chose to attempt it, happier still if you succeeded, but
I'm still not going to give any credit :-)

For each program, the points are awarded as follows:

   5 points   for working assembly code that answers the question.
              We're not looking for professional quality code, so
              as long as your program works, it doesn't matter if
              you've only used a limited set of registers, or if
              your code had some sources of inefficiency that could
              have been eliminated by using fancier instructions or
              addressing modes, etc.

   2 points   for appropriate commenting and explanatory text

   3 points   for evidence of thoughtful testing
              As a rough guide:
              - Saying only "I ran some tests" scores 0 points.
              - Showing complete output from a test run with no
                commentary and no attempt to trim the output to
                include relevant parts scores 1 point.
              - Showing output from a test with commentary that
                explains what the test was intended to verify and
                why the output accomplishes that scores 2 points.
              - Showing output that describes multiple tests (and,
                in the case of programs 4, 5, 6, covers multiple
                cases) scores 3 points.
              These guidelines will be interpreted liberally in
              cases where there is evidence of thoughtful testing
              and none of the above descriptions seems to fit!

------------------------------------------------------------------------
Program 1: The result should be the total number of "pixels" in the
           two input images.  The images themselves should not be
           modified.  The total number of pixels in a single image,
           of course, is just the width of the image multiplied by
           the height.

For this program, we can use indexed addressing to retrieve the widths
and heights of the two images, and then compute the total number of
pixels using a pair of multiplies and a single add.  The following code
is all that we need to complete this task:

        movl    (%esi), %eax  # width of first image ...
        imull   4(%esi), %eax # ... times height of first image
                              # gives #pixels in first image in eax

        movl    (%edi), %ebx  # width of second image ...
        imull   4(%edi), %ebx # ... times height of second image
                              # gives #pixels in second image in ebx

        addl    %ebx, %eax    # total #pixels is now in eax

For testing, I inserted the above code into the appropriate template
for my machine, then compiled and ran it using the instructions that
were provided.  The abbreviated output from this was as follows:

   Image has width 16 and height 17
   Image has width 16 and height 17
   Here is the first image:
   ...
   Here is the second image:
   ...
   Result of call is 544
   Here is the first output image:
   ...
   Here is the second output image:
   ...

By visual inspection, I confirmed that the images (not shown here) had
not been changed.  In addition, using the data about image size that is
included at the beginning of the output, I computed the total number of
pixels in the two images as:

   16 * 17 + 16 * 17 = 272 + 272 = 544

This figure agrees with the output from the program.

As a further test, I made a copy of main.c (altmain.c), edited it to use
a different image, and then repeated the above test using altmain.c in
place of main.c.  The results were as follows:

   Image has width 16 and height 15
   Image has width 16 and height 14
   Here is the first image:
   ...
   Here is the second image:
   ...
   Result of call is 464
   Here is the first output image:
   ...
   Here is the second output image:
   ...

Again, visual inspection confirmed that the images were preserved, and
the result of the call shows 464, which is the correct result for the
number of pixels in this case:

  16 * 15 + 16 * 14 = 240 + 224 = 464

------------------------------------------------------------------------
Program 2: The result should be the total number of spaces in the
           first input image.  (In case you don't know, the numeric
           code for a space character is 32).  Again, neither of the
           images should be modified by this operation.

For this program, I will use the %eax register to count the number of
space characters that are found in the first image.  As a result, the
%eax register will already contain the value that is supposed to be
returned at the end of the function.  The program starts by counting
the total number of pixels in the whole image by multiplying the values
of the first two numbers in the image data and storing the result in
ecx.  If this is zero, then the image is empty and we can return right
away.  Otherwise we loop through the pixels, decrementing ecx each time
to determine when the loop should terminate.

        movl    $0, %eax      # Use eax to count spaces
        movl    (%esi), %ecx  # width of first image ...
        imull   4(%esi), %ecx # ... times height of first image
                              # gives total #pixels in ecx

        cmpl    $0, %ecx      # test for an empty image
        jz      done

        addl    $8, %esi      # point esi to start of pixel data

loop:   cmpl    $32, (%esi)   # is this pixel a space?
        jnz     nocount       # if not, don't count it
        incl    %eax
nocount:addl    $4, %esi      # move esi past this pixel
        decl    %ecx          # decrease counter
        jnz     loop          # repeat if more pixels to process
done:

For testing, I decided that I would modify the C code in main.c (and so
also in altmain.c) to count spaces as part of the code for makeImage();
this means that I am computing the number of spaces twice in my tests,
once using C code, and once using assembly code.  If the two agree, then
chances are good that I got the algorithm right.  (For completeness, I
also tried counting the number of spaces myself by hand, just in case I
had got both versions of the space-counting code wrong in the same way.)
The (abbreviated) output from my tests was as follows:

 main.c:
   Image has width 16 and height 17
   Image has 204 spaces
   Image has width 16 and height 17
   Image has 197 spaces
   ...
   Result of call is 204
   ...
   
 altmain.c:
   Image has width 16 and height 15
   Image has 176 spaces
   Image has width 16 and height 14
   Image has 149 spaces
   ...
   Result of call is 176
   ...

Note that, in both cases, the result of the call is the same as the
value displayed using makeImage(); these values also matched my hand
counts.

------------------------------------------------------------------------
Program 3: The result should be 1 and the first image should be
           rotated through 180 degrees without modifying the second
           image.  [Hint: think what happens when you reverse the
           order of the pixels in the array ...]

Following the hint, we can implement this program by reversing the
order of the pixels in the array following the 2 word header of size
information.  For this to work, we set %esi to point to the first pixel
in the image, and %eax to point to the last pixel in the image, and then
begin swapping pairs of pixels.  After each swap, we advance esi to the
next pixel (add 4) and move edi back to the previous pixel (subtract 4).
This process continues until esi is not less than eax; at that point, we
know that we have reversed the full array, and our job is done:

        movl    (%esi), %eax  # width of first image
        imull   4(%esi), %eax # ... times height of first image
        imull   $4, %eax      # ... times four
                              # ... gives #bytes in first image

        addl    $8, %esi      # point esi to start of pixel data

        addl    %esi, %eax    # point eax to first byte after image
        subl    $4, %eax      # and then to last pixel

loop:   cmpl    %eax, %esi    # is esi < eax?
        jnl     done          # if not, then we are done!

        movl    (%esi), %ebx  # load first pixel
        xchgl   (%eax), %ebx  # swap second pixel
        movl    %ebx, (%esi)  # save swapped first pixel

        addl    $4, %esi      # move esi on to next pixel
        subl    $4, %eax      # and eax back to previous pixel
        jmp     loop          # then continue
        
done:   movl    $1, %eax      # set return result

For testing, I used by the main.c and altmain.c code described above,
checking in each case that the correct result (1) was returned and
relying on visual inspection to determine that the first image had been
inverted while the second was unchanged.  The following shows the
output produced by running against main.c, edited to show the output in
a second column next to the input images to make visual comparison
easier:

   Image has width 16 and height 17
   Image has 204 spaces
   Image has width 16 and height 17
   Image has 197 spaces
   Here is the first image:      Here is the first output image:     
       xxxxxxxx                        xxxx                          
      x        x                     xx    xx                        
     x          x                   x        x                       
    x            x                 x          x                      
   x              x               x   xxxxxx   x                     
   x    x    x    x              x   x      x   x                    
   x   xxx  xxx   x              x      xx      x                    
   x    x    x    x              x     xxxx     x                    
   x              x              x              x                    
   x     xxxx     x              x    x    x    x                    
   x      xx      x              x   xxx  xxx   x                    
   x   x      x   x              x    x    x    x                    
    x   xxxxxx   x               x              x                    
     x          x                 x            x                     
      x        x                   x          x                      
       xx    xx                     x        x                       
         xxxx                        xxxxxxxx                        
   Here is the second image:     Here is the second output image:    
   RRRRRRRRRRRR                  RRRRRRRRRRRR                        
   RR          RR                RR          RR                      
   RR           RR               RR           RR                     
   RR            RR              RR            RR                    
   RR            RR              RR            RR                    
   RR           RR               RR           RR                     
   RR        RRRR                RR        RRRR                      
   RRRRRRRRRRRR                  RRRRRRRRRRRR                        
   RR        RRR                 RR        RRR                       
   RR          RR                RR          RR                      
   RR           RR               RR           RR                     
   RR            RR              RR            RR                    
   RR            RR              RR            RR                    
   RR            RR              RR            RR                    
                                                                     
                                                                     
                                                                     
   Result of call is 1

------------------------------------------------------------------------
Program 4: If the two input images have the same width and height,
           then the result should be the integer 42 and every
           "pixel" in both images should be replaced with the
           character "*".  (And again, in case you don't know, the
           numeric code for the * character is also 42!)

There are two parts to this exercise:

- Check that the two input images have the same size.  This requires
  two separate tests, one to compare widths, and another to compare
  heights.  If either test fails, the we branch to some code (at the
  label "diff") that loads the required 0 return value into eax before
  returning to the calling code.  If both tests succeed, then we load
  eax with the number 42, which will serve both as our final return
  code and as the character value that we will use for output pixels.

- Overwrite each pixel in both images with the appropriate number of
  asterisk characters (ascii code 42).  The total number of pixels is
  calculated by multiplying the height and width of the two images.
  Because we have already verified that the two images have the same
  size, we can fill in both images using a single loop.

The complete code is as follows:

        # check that widths and heights of two images are the same:

        movl    (%esi), %ebx  # get width of first in ebx
        cmpl    (%edi), %ebx  # compare with width of second
        jnz     diff

        movl    4(%esi), %ecx # get height of first in ecx
        cmpl    4(%edi), %ecx # compare with height of second
        jnz     diff

        movl    $42, %eax     # return value, as well as code for *

        # now we can do the real work of trashing both images

        imull   %ebx, %ecx    # calculate #pixels in ecx
        addl    $8, %esi      # move esi to start of first image pixels
        addl    $8, %edi      # move edi to start of second image pixels

        cmpl    $0, %ecx      # special case for empty image
        jz      done

loop:   movl    %eax, (%esi)  # write * into first image
        addl    $4, %esi      # advance pointer
        movl    %eax, (%edi)  # write * into second image
        addl    $4, %edi      # advance pointer
        decl    %ecx          # decrement count
        jnz     loop
        jmp     done

diff:   movl    $0, %eax      
done:

Note here that I used an "addl $8, %esi" just before the loop (and
something similar for edi) to skip past the two words (i.e., 8 bytes)
that hold the image size data.  An alternative would have been to skip
that instruction, and then access image data in the following code
using 8(%esi) instead of (%esi).  I wanted to keep things simple for
this example, but I will use this trick in subsequent questions ...

As another aside, another variation in the code above would have been
to start by loading %eax with zero, the return code to be used in the
case where the images differ in size.  This would mean that we could
eliminate the code at label "diff", jumping directly to "done" if an
error case (different image sizes) had been detected.  At first glance,
however, it might appear that this is not an improvement in the case
where no error occurs because it does unnecessary work, loading eax
with a value that will be promptly be overwritten.  Note, however, that
by eliminating the code at "diff", we also eliminate the need for the
"jmp done" instruction.  As a result, even with an extra "movl $0, %eax"
instruction, we still end up executing the same number of instructions
in both the success and failure cases, and the program becomes one
instruction shorter: a gain in space, with no cost in time (possibly
even some improvement because we eliminate a jump).  This level of
cunning and control is not too hard to achieve in handwritten assembler,
but it can be more difficult for a compiler.  We'll also be using this
trick in the following programs.

For testing, there are at least two cases to consider.  The first is to
check that the program behaves correctly when the two images are of the
same size.  In that case, an output result of 42 is required, and the
images must be overwritten with asterisks.  The following output,
produced by compiling against the supplied main.c and running the
resulting code shows this behavior (once again, relying on visual
inspection to confirm the results, and formatted to show output next to
input):

   Image has width 16 and height 17
   Image has 204 spaces
   Image has width 16 and height 17
   Image has 197 spaces
   Here is the first image:      Here is the first output image: 
       xxxxxxxx                  ****************                
      x        x                 ****************                
     x          x                ****************                
    x            x               ****************                
   x              x              ****************                
   x    x    x    x              ****************                
   x   xxx  xxx   x              ****************                
   x    x    x    x              ****************                
   x              x              ****************                
   x     xxxx     x              ****************                
   x      xx      x              ****************                
   x   x      x   x              ****************                
    x   xxxxxx   x               ****************                
     x          x                ****************                
      x        x                 ****************                
       xx    xx                  ****************                
         xxxx                    ****************                
   Here is the second image:     Here is the second output image:
   RRRRRRRRRRRR                  ****************                
   RR          RR                ****************                
   RR           RR               ****************                
   RR            RR              ****************                
   RR            RR              ****************                
   RR           RR               ****************                
   RR        RRRR                ****************                
   RRRRRRRRRRRR                  ****************                
   RR        RRR                 ****************                
   RR          RR                ****************                
   RR           RR               ****************                
   RR            RR              ****************                
   RR            RR              ****************                
   RR            RR              ****************                
                                 ****************                
                                 ****************                
                                 ****************                
   Result of call is 42

The second case to consider is when the input images have different
sizes.  In that case, the images should not change, and a result of 0
should be produced.  The following (abbreviated) output demonstrates
this behavior using the (differently sized) images from altmain.c.  The
images themselves are not shown, but visual inspection did not show any
changes.  (It might also have been nice to write a function for
comparing two images so that tests for unchanged images could be
automated.)

   Image has width 16 and height 15
   Image has 176 spaces
   Image has width 16 and height 14
   Image has 149 spaces
   ...
   Result of call is 0
   Here is the first output image:
   ...

If your testing did not check for the case where the two images have
different sizes, then you have not used an adequate testing strategy!

------------------------------------------------------------------------
Program 5: If the two input images have the same width and height,
           then the result should be 1 and the first image should
           be overwritten with a copy of the second image.

This program follows a similar pattern to the code for Program 4, but
I have incorporated the two programming tricks described previously to
demonstrate how these work (using 8(%esi), etc. to access pixel data and
loading %eax with a return result for the fail case at the beginning of
the code).

        # check that widths and heights of two images are the same:

        movl    $0, %eax      # result if images are different size

        movl    (%esi), %ebx  # get width of first in ebx
        cmpl    (%edi), %ebx  # compare with width of second
        jnz     done

        movl    4(%esi), %ecx # get height of first in ecx
        cmpl    4(%edi), %ecx # compare with height of second
        jnz     done

        # now we can do the real work of copying image 2 to image1

        movl    $1, %eax      # return value for successful copy

        imull   %ebx, %ecx    # calculate #pixels in ecx
        cmpl    $0, %ecx      # special case for empty image
        jz      done

loop:   movl    8(%edi), %ebx # get second image pixel
        movl    %ebx, 8(%esi) # write to second image
        addl    $4, %esi      # advance pointer
        addl    $4, %edi      # advance pointer
        decl    %ecx          # decrement count
        jnz     loop

done:

My testing strategy for this program was essentially the same as the
strategy that I used for Program 4.  In particular, this requires
running tests to cover both the cases when the two images are of the
same size, as in main.c:


   Image has width 16 and height 17
   Image has 204 spaces
   Image has width 16 and height 17
   Image has 197 spaces
   Here is the first image:    Here is the first output image: 
       xxxxxxxx                RRRRRRRRRRRR                    
      x        x               RR          RR                  
     x          x              RR           RR                 
    x            x             RR            RR                
   x              x            RR            RR                
   x    x    x    x            RR           RR                 
   x   xxx  xxx   x            RR        RRRR                  
   x    x    x    x            RRRRRRRRRRRR                    
   x              x            RR        RRR                   
   x     xxxx     x            RR          RR                  
   x      xx      x            RR           RR                 
   x   x      x   x            RR            RR                
    x   xxxxxx   x             RR            RR                
     x          x              RR            RR                
      x        x                                               
       xx    xx                                                
         xxxx                                                  
   Here is the second image:   Here is the second output image:
   RRRRRRRRRRRR                RRRRRRRRRRRR                    
   RR          RR              RR          RR                  
   RR           RR             RR           RR                 
   RR            RR            RR            RR                
   RR            RR            RR            RR                
   RR           RR             RR           RR                 
   RR        RRRR              RR        RRRR                  
   RRRRRRRRRRRR                RRRRRRRRRRRR                    
   RR        RRR               RR        RRR                   
   RR          RR              RR          RR                  
   RR           RR             RR           RR                 
   RR            RR            RR            RR                
   RR            RR            RR            RR                
   RR            RR            RR            RR                
                                                               
                                                               
                                                               
   Result of call is 1
   
as well as tests to cover the case when the images have different
sizes, as in altmain.c:

   Image has width 16 and height 15
   Image has 176 spaces
   Image has width 16 and height 14
   Image has 149 spaces
   Here is the first image:
   ...
   Result of call is 0
   Here is the first output image:
   ...

------------------------------------------------------------------------
Program 6: If the two input images have the same width and height,
           then the first image should be modified to contain a
           "merged" version of the two images.  ... details omitted ...

Again, the basic structure for this program is similar to that of
Programs 4 and 5, the only real difference being a conditional test
inside the loop body to make sure we count the number of non-space
characters 

        # check that widths and heights of two images are the same:

        movl    $0, %eax      # result if images are different size

        movl    (%esi), %ebx  # get width of first in ebx
        cmpl    (%edi), %ebx  # compare with width of second
        jnz     done

        movl    4(%esi), %ecx # get height of first in ecx
        cmpl    4(%edi), %ecx # compare with height of second
        jnz     done

        # now we can do the real work of copying image 2 to image1

        imull   %ebx, %ecx    # calculate #pixels in ecx
        cmpl    $0, %ecx      # special case for empty image
        jz      done

loop:   movl    8(%edi), %ebx # get second image pixel
        cmpl    $32, %ebx     # if it is a space, ...
        jz      skip          # ... then don't overwrite image1 pixel
        incl    %eax          # otherwise increment count
        movl    %ebx, 8(%esi) # and copy pixel
        
skip:   addl    $4, %esi      # advance pointer
        addl    $4, %edi      # advance pointer
        decl    %ecx          # decrement count
        jnz     loop

done:

Testing also follows the same pattern as in the previous cases.  For
example, the output from the version produced by compiling against
main.c is as follows:

   Image has width 16 and height 17
   Image has 204 spaces
   Image has width 16 and height 17
   Image has 197 spaces
   Here is the first image:    Here is the first output image: 
       xxxxxxxx                RRRRRRRRRRRR                    
      x        x               RR x        RR                  
     x          x              RRx          RR                 
    x            x             RR            RR                
   x              x            RR            RR                
   x    x    x    x            RR   x    x  RRx                
   x   xxx  xxx   x            RR  xxx  xRRRR x                
   x    x    x    x            RRRRRRRRRRRR   x                
   x              x            RR        RRR  x                
   x     xxxx     x            RR    xxxx  RR x                
   x      xx      x            RR     xx    RRx                
   x   x      x   x            RR  x      x  RR                
    x   xxxxxx   x             RR   xxxxxx   RR                
     x          x              RRx          xRR                
      x        x                  x        x                   
       xx    xx                    xx    xx                    
         xxxx                        xxxx                      
   Here is the second image:   Here is the second output image:
   RRRRRRRRRRRR                RRRRRRRRRRRR                    
   RR          RR              RR          RR                  
   RR           RR             RR           RR                 
   RR            RR            RR            RR                
   RR            RR            RR            RR                
   RR           RR             RR           RR                 
   RR        RRRR              RR        RRRR                  
   RRRRRRRRRRRR                RRRRRRRRRRRR                    
   RR        RRR               RR        RRR                   
   RR          RR              RR          RR                  
   RR           RR             RR           RR                 
   RR            RR            RR            RR                
   RR            RR            RR            RR                
   RR            RR            RR            RR                
                                                               
                                                               
                                                               
   Result of call is 75

Note here that the data from the second image takes priority over
data from the first in the merged output, as required.  (In specific
terms, we can see that all of the R characters appear in the result,
some of which replace x characters from the original first image.)
Note also that the return result is 75, which is supposed to be a count
of the non-space characters in the second image.  According to the data
displayed, the number of space characters is 197, which suggests a total
of 75 + 197 = 272 characters/pixels in total; happily this agrees with
the size 16 * 17 = 272 that we can compute by multiplying the width and
height attributes for the two images.  As such, this test shows that the
program is producing the correct output, at least in this case!

Proper testing also requires that we run the program in a context where
the two images have different sizes to confirm that an output value of
0 is produced.


------------------------------------------------------------------------
Program 7: If the two inputs are square images with the same width and
           height, then the first image should be replaced with a copy
           of the second that has been rotated through 90 degrees
           clockwise.

This was an optional part of the assignment.  I include my code for
this program below, annotated with plenty of comments to explain how it
works.  There are other ways to solve this problem, particularly if you
are willing to stray a little outside the set of instructions that I
have described in class (in particular, using some of the x86's more
advanced addressing modes), but I wanted to show you one way to solve
this problem using only the simple forms of instructions from class.

        # Check that widths and heights of two images are the same:

        movl    (%esi), %ebx  # get width of first in ebx
        cmpl    (%edi), %ebx  # compare with width of second
        jnz     done

        movl    4(%esi), %ecx # get height of first in ecx
        cmpl    4(%edi), %ecx # compare with height of second
        jnz     done

        # Set the size of the first image (swapping rows and columns):
        # If the size of the second image is width=w2, height=h2, then
        # the size of the output should be width=w1=h2, height=h1=w2

        movl    %ecx, (%esi)  # ecx = w1 = h2
        movl    %ebx, 4(%esi) # ebx = h1 = w2

        # Test for an empty image as a special case:

        orl     %ecx, %ecx
        jz      done
        orl     %ebx, %ebx
        jz      done

        # The following code works by copying columns, one at a time,
        # from the second image into corresponding rows in the second.
        # This allows us to move through the pixels of the second image
        # in the same order that they are stored in memory; we start
        # with edi pointing to the start of the second image, used
        # 8(%edi) to read the current pixel, and add 4 to %edi to move
        # on to the next pixel.  More work is required to move through
        # the first image.  We start with esi pointing to the end of the
        # first row, add (w1*4) after writing each pixel to move to the
        # same column position in the next row, and then subtract the
        # value (w1*h1+1)*4 at the end of each column to move esi back
        # to the first pixel in the previous row.  The following diagram
        # shows how positions in the first image (the column) relate to
        # positions in the second (the row):
        #
        #       Image 1:                   Image 2:
        #       w1 h1 .. .. .. .. .. ||    w2 h2 == == == =>
        #             .. .. .. .. .. ||          .. .. .. ..
        #             .. .. .. .. .. ||          .. .. .. ..
        #             .. .. .. .. .. \/          .. .. .. ..
        #                                        .. .. .. ..
        #                                        .. .. .. ..
        #
        # We start by computing the value of w1*4 and saving this in edx
        # so that it can be used at multiple points later in the code.
        # In particular, adding this result to the initial value of esi
        # gives the required starting address for the rightmost column
        # of Image 1, minus 4, and we can compensate for being off by
        # 4 in the following code using 4(%esi) to reference locations
        # in the first image.

        movl    %ecx, %edx    # compute edx = 4*w1
        imull   $4, %edx
        addl    %edx, %esi    # find location of last pixel on first row

        # loop through columns:

loop:   pushl   %ebx          # save column count
        # copy a row in the second image to a column in the first:
inner:  movl    8(%edi), %eax # copy a pixel from the second image
        movl    %eax, 4(%esi) # to the first
        addl    $4, %edi      # move along second image row
        addl    %edx, %esi    # move down first image column
        decl    %ebx          # finished this row/column yet?
        jnz     inner
        popl    %ebx          # restore column count

        movl    %edx, %eax    # move back to start of previous column
        imull   %ebx, %eax    
        addl    $4, %eax
        subl    %eax, %esi

        decl    %ecx
        jnz     loop

        # We are done!

done:

As for testing, I'll keep this brief (after all, I wasn't giving any
credit for this, even to myself :-), but I will show one part of the
output produced by running against main.c.  In this particular case,
the displays of the two images are shown side by side after the above
code has been run:

   Here is the first output image:   Here is the second output image:
      RRRRRRRRRRRRRR                 RRRRRRRRRRRR     
      RRRRRRRRRRRRRR                 RR          RR   
            R      R                 RR           RR  
            R      R                 RR            RR 
            R      R                 RR            RR 
            R      R                 RR           RR  
            R      R                 RR        RRRR   
            R      R                 RRRRRRRRRRRR     
            R      R                 RR        RRR    
            R      R                 RR          RR   
           RRR     R                 RR           RR  
           RRR     R                 RR            RR 
          RR R    R                  RR            RR 
         RR  RR  RR                  RR            RR 
      RRRR    RRRR                                    
      RRR      RR                                     

One particularly important special case that you might also want to
test for in an example like this is whether your program deals
correctly with images that are not square.  The code above, does indeed
handle this case, and that's one of the reasons why it overwrites the
width and height fields for the first image once it has confirmed that
the two inputs are the same size.  (Technically speaking, for this
program, it would have been sufficient to confirm only that the two
images have the same number of pixels, and not to insist that they have
exactly the same dimensions ... but the question asked for the stronger
condition, so that's what I did!)

------------------------------------------------------------------------
