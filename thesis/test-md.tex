\documentclass{article}
\input{preamble}
\begin{document}

\var v/ with the \setL{Clo} value $(\lab l/, \var v_1/, \dots, \var
v_n/)$. Our result set shows that \var v/ now refers to the closure

\begin{math}
  \begin{array}{rlr}
    \setL{Clo} &= \{(\lab l/, \var v_1/, \dots, \var v_n/)\ ||\ \lab l/ \in \setL{Labels}, \var v_i/ \in \setL{Var}, n \geq 0\}.\\
    t (F, \binds v\ <-\ \mkclo[l:v_1, \dots, v_n];) &= \\
  \end{array}
\end{math}

!+foo+!

\begin{AVerb}
  \block absBlockL209 (f):
  \vbinds v210 <- \mkclo[absBodyL201:];
  \mkclo[absBodyL202:f]
\end{AVerb}

\begin{AVerb}
  \vbinds v1 <- \app v0 * n/;
  \vbinds v2 <- \app v1 * n/;
  \return v2; 
\end{AVerb}

function from $F$.  We combine this set with a a new fact associating
\var v/ with the \setL{Clo} value \clo[l:v_1, \dots, v_n]. Our result
set shows that \var v/ now refers to the closure \clo[l:v_1, \dots,
  v_n], and does not include any previous facts that referred to \var
v/.

Recall \clo[k0:] 
that MIL defines two types of blocks: ``\cc'' and ``normal.''
Normal blocks act much like labeled locations in a program and are
written \block b(v_1, \dots, v_n): \dots.  A normal block is
called using MIL's !+goto+! expression, and receives any arguments
given. 

\lab foo/ \goto foo(bar)
\goto foo$!+_i+!$(bar)

\lab k$_i$/ 

\ensuremath{\mathbf k_i}

\ensuremath{\mathtt k_i}

\begin{myfig}
  \caption{Our rewrite function that replaces \app f * x/ expressions
    with closure allocations, if possible. \lab fooo/.}
  \label{uncurry_fig_rewrite}
\end{myfig}

\begin{AVerb}
  \vbinds v1 <- \app v0 * n/;
  \vbinds v2 <- \app v1 * n/;
  \return v2; 
\end{AVerb}

  \binds v1 <- \app v0 * n/;

  \binds v2 <- \app v1 * n/;

  \return v2; 
\listoffigures
\end{document}

