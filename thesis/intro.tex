\documentclass[11pt]{article}
\begin{document}
\section{Grand Vision -- The Caffeine Compiler}

Ultimately, I want to build a compiler for the Habit language,
targetting the Intel x86 32-bit platform. The compiler will produce
programs that can run under Windows and Linux. 

My thesis statment has three parts:

\begin{itemize}
\item The compiler does not introduce any intermediate languages -- it
  only translates from Habit to Habit or from Habit to a assembly
  language.
\item The compiler preserves types during Habit to Habit
  transformations. It also preserves types when translating to
  assembly language.
\item A run-time system for Habit can be written in Habit and built
  using the Caffeine compiler.
\end{itemize}

\begin{itemize}
\item \textbf{``Monadic'' code gen}. Habit programs will be compiled
  to an assembly-like, monadic form. Each transformation on the source
  code will result in a valid Habit program. The goal is to transform
  Habit programs to a form as close to assembly language as possible,
  without introducing any other intermediate languages.
\item \textbf{Proven type-preserving compilation}. Each transformation 
  results in a valid, typed Habit program. Types may be change to reveal
  more implementation detail and a proof that each change is correct will
  need to be provided. The final translation from Habit to assembly language
  will also be shown to preserve types.
\item \textbf{Implement Habit runtime system, in Habit.} A run-time
  system implementing garbage collection and I/O services will be
  implemented using the Habit language. The source used to build the
  run-time may use primitives not available to programs which the
  run-time hosts. For example, supporting garbage collection will
  require primitives for explicitly allocating and freeing memory.
\end{itemize}

\subsection{``Monadic'' code gen}

I want to explore how a simple function like |add| can be transformed
to reveal more and more implementation detail. First, the initial,
high-level definition:

> add :: Int -> Int -> Int
> add a b = a + b

Adding two integers requires that they be placed in registers. This
next transformation shows how the values are moved into registers and
then added.

> add :: Int -> Int -> Asm (EAX Int)
> add a b = do
>   movl a R.ebx -- R is a module defining registers
>   movl b R.ecx
>   addl R.ebx R.ecx

|Asm (EAX Int)| shows that the |eax| register will contain an |Int|
value after |add| executes. The function does not talk about where the
arguments come from, though. The next form does away with the function
arguments and gets them from the stack.

> add :: Asm2 (EBP 8 Int (EBP 4 Int)) (EAX Int)
> add = do 
>   a <- at R.ebp 8
>   b <- at R.ebp 4 
>   movl a R.ebx
>   movl b R.ecx
>   addl R.ebx R.ecx

|Asm2 (EBP 8 Int (EBP 4 Int)) (EAX Int)| gives the pre and
post-condition for the function. |(EBP 8 Int (EBP 4 Int))| says the
stack should contain |Int| values at offset 8 and 4,
respectively. |(EAX Int)| still says the function should return an
|Int| in |eax|.

This function updates |a| and |b| so they point
to the other's value after |swap| executes.

> swap :: Ptr a -> Ptr a -> m ()
> swap a b = do
>   t <- alloc (sizeof a) -- Create temporary space for a
>   poke t a -- Write a's value into t.
>   poke a b -- Write b's value into a. a points to b's value now.
>   poke b t -- Write t's value into b. 

\end{document}
