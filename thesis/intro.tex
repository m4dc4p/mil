%&preamble
\input{nodocclass}\dodocclass
\begin{document}
\input{document.preamble}

\chapter{Introduction}

\intent{Introduce the algorithm and what it does.}
The \emph{dataflow algorithm} treats programs as \emph{control-flow}
graphs, with edges representing execution paths and nodes representing
statements or expressions. A particular dataflow analysis computes
some desired property for each node in the graph based on a static
approximation of the program's run-time behavior. The results of the
analysis can then be used to optimize the program according to some
measure, such as execution time, memory usage, or power
consumption. 

\intent{Describe traditional application of dataflow analysis to imperative programs.}
The first publication of the dataflow algorithm \citep{Kildall1973}
described a number of optimizations for programs written in \algol, an
imperative programming language. Research and refinements since then
continued to focus on imperative languages.

\intent{Contrast dataflow analysis with rewrite based transformations} In
contrast, much research on the analysis and optimization of programs
written in functional programming languages focuses on algebraic,
rewrite-based techniques. This approach searches for syntactic
patterns in the program's text and rewrites those patterns according
to some set of rules.

\intent{Describe why dataflow analysis is not typically used for functional languages.}
No technical reason prevents the dataflow algorithm from being applied
to functional language programs, but the technique has not been widely
used. Tradition may play a role here, as well as pragmatic
reasons. Rewriting programs according to syntactic patterns, when
those programs are written as a set of ``equational'' definitions, seems much
simpler than specifying transformations based on control-flow
analysis. 

\intent{Introduce monadic programming style.}
Programs written in monadic style, as exemplified by the Haskell
programming language, lend an imperative flavor to functional
programs. Monadic programs typically impose explicit control-flow on
the execution of the program, give the appearance of incrementally
updating program variables, and allow imperative side-effects such as
writing to the screen or reading input from the user.

\intent{Thesis: Interesting things happen when we apply dataflow analysis to \mil.}
This work explores the application of the dataflow algorithm to
programs written in a \emph{monadic intermediate language}
(\mil). \Mil is a pure, functional language like Haskell, which 
requires all programs to be written in monadic style.  We will show
that dataflow analysis over \mil programs can implement both
functional-language specific and traditional imperative optimizations.

\intent{Signposts for dataflow chapter.} Chapter~\ref{ref_chapter_background}  gives 
a thorough introduction to the dataflow algorithm in its traditional
setting. We explain the algorithm by
applying \emph{constant-propagation} to a simple C program. We
introduce fundamental definitions used throughout this thesis, such as
control-flow graphs and basic blocks. We discuss the theoretical basis
of the algorithm, including its correctness and the quality of its
solutions. Finally, we give the \emph{dataflow equations} that can be
used to describe any particular dataflow analysis.

\intent{Signposts for \hoopl chapter.} In Chapter~\ref{ref_chapter_hoopl},
we describe \hoopl \citep{Hoopl-3.8.7.0}, a Haskell implementation of
the dataflow algorithm that we used to prototype all dataflow analyses
described in this work. This chapter follows the structure of
Chapter~\ref{ref_chapter_background}, emphasizing the connection
between the theoretical description of the dataflow algorithm
and \hoopl's implementation. We use \emph{dead-code elimination} for a
subset of the C programming language as a running example.

\intent{Signposts for \mil chapter.} We introduce our monadic 
intermediate language (\mil) in Chapter~\ref{ref_chapter_mil},
describing its syntax, features, and design goals. We also introduce
\lamC, a simple, high-level functional language that we use
to define example programs that will be translated to \mil. We also
discuss \hoopl's impact on the \ast that we implemented to
represent \mil programs.

\intent{Signposts for Uncurrying chapter.} Chapter~\ref{ref_chapter_uncurrying} brings
together the concepts introduced in previous chapters and describes
the \emph{uncurrying} optimization. We motivate the optimization,
formulate it in terms of the dataflow algorithm, and show how it applies
to \mil programs. We then describe how we implemented the optimization
using \hoopl.

\intent{conclude} In Chapter~\ref{ref_chapter_conclusion} we 
discuss several ways in which this work could be extended. We describe
how \mil programs can be optimized using only the \emph{monad
laws}. We briefly discuss dead-code elimination in \mil programs. We
also sketch a more aggressive transformation of \mil programs that
uses dataflow analysis of case alternatives to eliminate unnecessary
allocations. We offer some reflections based on our experience
with \hoopl, proposing ways in which we feel the library could be
improved. Finally, we summarize our goals and the contributions of
this work.

\end{document}
