%&preamble
\input{nodocclass}\dodocclass
\begin{document}
\input{document.preamble}

\chapter{Introduction}

\intent{Introduce the algorithm and what it does.}
The \emph{dataflow algorithm} treats programs as \emph{control-flow}
graphs, with edges representing execution paths and nodes representing
statements in the program. A particular dataflow analysis computes
some desired property for each node in the graph based on a static
approximation of the program's run-time behavior; the results of the
analysis can be used to transform the program. In most cases this
transformation optimizes the program according to some measure, such
as making it run faster, use less memory, or consume less power.

\intent{Describe traditional application of dataflow analysis to imperative programs.}
Kildall invented the dataflow algorithm \citep{Kildall1973} and applied it to
programs written in \textsc{algol 60},
an imperative programming language. Research and refinements since then
continued to focus on imperative languages, as the algorithm applies
naturally to languages with explicit control-flow.

\intent{Contrast dataflow analysis with rewrite based transformations} In
contrast, much research on the analysis and optimization of programs
written in functional programming languages focuses on algebraic,
rewrite-based techniques. This approach searches for syntactic
patterns in the program's text and rewrites those patterns according
to some set of rules. The goal remains the same, namely producing a
program optimized according to some criteria. 

\intent{Introduce idea of dataflow analysis over \mil.}
Dataflow analysis on imperative programs arises naturally due to the
explicit flow-of-control from statement to statement. For functional
languages, with flow-of-control determined by evaluation order, the
fit seems more awkward. However, \emph{monadic} functional programs
embody the best of both styles: expression-based evaluation \emph{and}
explicit control-flow.

\intent{Thesis: Interesting things happen when we apply dataflow analysis to \mil.}
We propose that dataflow analysis can be used quite effectively on
programs written in our \emph{monadic intermediate language} (\mil), a
pure, monadic, functional language of our own design. We will show
that dataflow analysis can be used to implement functional-language
specific optimizations and that our \mil lends itself to established
dataflow analyses, such as dead-code elimination.

\intent{Signposts for dataflow chapter.} Chapter~\ref{ref_chapter_background}  gives 
a thorough introduction to the dataflow algorithm in its traditional
setting. We explain the algorithm by
applying \emph{constant-propagation} to a simple C program. We
introduce fundamental definitions used throughout this thesis, such as
control-flow graphs and basic blocks. We discuss the theoretical basis
of the algorithm, including its correctness and quality of
solutions. Finally, we give the \emph{dataflow equations} that can be
used to describe any particular dataflow analysis.

\intent{Signposts for \hoopl chapter.} In Chapter~\ref{ref_chapter_hoopl},
we describe how to use \hoopl \citep{Hoopl-3.8.7.0}, a Haskell library
used to implement all dataflow analyses described in this document. We
use the same structure for this chapter as the previous, making the
connection between the more abstract description of the dataflow
algorithm and \hoopl's implementation
explicit. Chapter~\ref{ref_chapter_hoopl} uses \emph{dead-code
elimination} for a subset of the C programming language as a running
example.\footnote{The Appendix gives the complete
source code for the program described.}k

\intent{Signposts for \mil chapter.} We introduce our monadic 
intermediate language (\mil) in Chapter~\ref{ref_chapter_mil}. We describe
\mil's design goals, syntax, and features. We also briefly describe
\lamC, the language used for the example programs in this Chapter and the next. We
discuss the more interesting challenges we faced compiling \lamC
to \mil. We also discuss \hoopl's impact on the \ast we implemented to
represent \mil programs.

\intent{Signposts for Uncurrying chapter.} Chapter~\ref{ref_chapter_uncurrying} brings
together the concepts introduced in previous chapters and describes our
\emph{uncurrying} optimization. We motivate the optimization and formulate it in terms
of dataflow equations applied to \mil programs. We then describe how
we implemented the optimization using \hoopl.

\intent{conclude} Concluding our work in Chapter~\ref{ref_chapter_conclude}, we discuss
several ways in which this work could be extended. We also reflect
on \hoopl, proposing ways in which we feel the library could be
improved. Finally, we summarize our goals and the contributions of this work.

\end{document}
