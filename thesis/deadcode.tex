\documentclass[12pt]{report}
 %include polycode.fmt
\include{preamble}
\begin{document}
\include{document.preamble}

\chapter{Dead-code elimination}

Dead-code elimination seeks to remove program statements that will not
be executed or which have no visible effect. It can be applied at multiple
points during compilation, as other transformations frequently introduce 
dead code. Without dead-code elimination, many other optimizations have
minimal effect, since they leave behind code which still executes even if
it is no longer needed.

\emph{Uncurrying} (descrbed in Chapter \ref{ref_chapter_uncurrying}), especially
when repeatedly applied, can leave behind many unusued bindings. Consider
this program, which executes @const3@ to return 3:

%% If only we actually supported local declarations ...
\begin{code}
main = 
  let const3 a b c = c 
  in const3 1 2 3
\end{code}

@main@ compiles to this monadic program:

%% -- Not strictly accurate, main
%% -- really is main <- mainK {}
%%
%% Do I need to implement inter-procedural
%% optimization since this actually won't 
%% get reduced?
\begin{code}
main = do
 t1 <- const3 @ 1
 t2 <- t1 @ 2
 t3 <- t2 @ 3
 return t3

const3 <- k1 {}
k1 {} a = k2 {a} 
k2 {a} b = k3 {a, b}
k3 {a, b} c = b(a,b,c)
b(a,b,c) = return c
\end{code}

Uncurrying will rewrite @t1 @@ 2@ as @k2 {1} @@ 2@:

\begin{code}
main = do
 t1 <- const3 @ 1
 t2 <- k2 {a} @ 2 -- TODO: Does syntax allow a closure value to be entered here?
 t3 <- t2 @ 3
 return t3
\end{code}

This changes makes @t1@ useless --- it causes an allocation but otherwise 
has no effect. Our dead-code elimination optimization will remove the binding.

%% \emph{The bulk of our work. Each optimization implemented is
%%   described. Each subsection should follow a common recipe: describe
%%   the optimization, give an example program and show how we want it
%%   changed, show salient points about the optimization (with code
%%   snippets and references to the full library), and reflect on the
%%   implementation.  Lazy Code Motion may get its own section.}

%% \emph{One question: should optimizations be categorized by direction? We could
%% describe all forward optimizations, then all backward ones. That may help
%% set up the concepts necessary to describe LCM.}

%% \emph{This portion gives an overview of the optimization, without
%% code or (much) notation. We motivate the optimization by 
%% showing an example.}

\section{Implementation}
We seek to remove two types of dead code: unused bindings (and,
therefore, allocation) and unused blocks. Each begins with a
``liveness'' analysis. Bindings (or blocks) that are referenced are ``live''
and therefore cannot be eliminated. Everything else is ``dead.'' 

\subsection{Eliminating Bindings}

A binding can be eliminated if no references to the bound variable
occur except the initial binding. We must travese each block
backwards, noting when a variable is used. We do not need to worry
about \emph{how} the variable is used, so we can just maintain a set
of variables. When we see a binding, we eliminate the bound variable
from the set, since variables can be bound more than once (and they
cannot be used before being bound).

%% TODO - leave out woTops?  

Figure \ref{ref_fig_liveTransfer} shows the algorithm for determining
liveness.  Top-level definitions are excluded from the set by the
@woTops@ function and are not considered here. 
At each statement, we add referenced or remove variables from
the live set @f@. \emph{Tail} (@Done@) and \emph{case} (@CaseM@)
statements add all referenced variables. Additionally, case statements
must inspect all alternatives and add the union of those
sets. @tailVars@ collects the variables used in a tail expression and
its definition is not shown here. \emph{Binding} (@Bind@) statements
remove the bound variable (@v@) and add any variables in the tail
(@t@).

\begin{figure}[h]
\begin{code}
live (Bind v t) f = Set.delete v f  `Set.union` tailVars mapEmpty t
live (CaseM v alts) f = Set.insert v (Set.unions (map (setAlt f) alts))
live (Done t) f = tailVars f t
\end{code}
\caption{Our transfer function for determing live variables within a block.}
\label{ref_fig_liveTransfer}
\end{figure}

With the facts collected by @live@, we can then eliminate useless
bindngs by looking up the bound variable in the set and removing the
binding if the variable is not there. The @deadRewrite@ functin, shown
in Figure \ref{ref_fig_deadRewrite}, gives our implementation of this
process. Recall that Hoopl interleaves analysis and rewriting.
Therefore, at each statement we know what variables will be live. When
a bind is seen, we check if the bound variable (@v@) is absent from
the live set (@f@). We also take a conservative view and only
eliminate safe (@safeTail@) operations from the tail @t@: data or closure
allocation, and @returns@. We then eliminate the binding when both are
true. Otherwise, we leave the program unchanged.

\begin{figure}[h]
\begin{code}
rewrite (Bind v t) f 
  | safe t && not (v `Set.member` f) = return (Just emptyGraph)
rewrite _ _ = return Nothing
\end{code}
\caption{Our rewrite function that elminates useless bindings.}
\label{ref_fig_deadRewrite}
\end{figure}

\subsection{Eliminating Blocks}

Though eliminating blocks which do not execute will not make the
program run faster, they do increase code size and memory footprint, making
it worthwhile to eliminate them. In this case, we analyze the program and
find all @Goto@ and @Closure@ statements, which in turn gives us all
possible label references. Since we do not have computed labels in our
language, we know that if a label is never referenced then it will
never be called. 

Figure \ref{ref_figure_liveBlocks} gives our code that finds all 
blocks called in the program. Each statement uses @tailDest@ to find
destination labels for @Goto@ and @Closure@ instructions. Hoopl runs
this function over the program to find the union of all the labels
referenced. 

\begin{figure}[h]
\begin{code}
live :: StmtM e x -> Fact x LiveBlock -> LiveBlock
live (Bind v tail) blocks = Set.fromList (tailDest tail) `Set.union` blocks

live (CaseM _ alts) blockSet = Set.unions (map (Set.fromList . tailDest . altExpr) alts 
  ++ mapElems blockSet)
live (Done tail) blockSet =  Set.unions (Set.fromList (tailDest tail) : mapElems blockSet)

live (BlockEntry _ l _) blocks = blocks
live (CloEntry _ l _ _) blocks = blocks
\end{code}
\caption{Our transfer function the finds all blocks called by the program.}
\label{ref_figure_liveBlocks}
\end{figure}

After collecting this information we look at the set of blocks in the
program and eliminate any that are not the destination of a @Goto@ or
@Closure@. Figure \ref{ref_figure_removeOrphan} shows the function
which we fold over all the blocks in the graph. Any blocks in the
@live@ set are retained (@blockGraph block |*><*| prog@ keeps them in
the graph). Otherwise, the block is dropped. The flag returned
indicates if any blocks were dropped and, if so, we run the dead-block
elimination again. Otherwise, we terminate.

\begin{figure}[h]
  \begin{code}
    removeOrphan :: LiveBlock 
                 -> (ChangeFlag, ProgM C C) 
                 -> (Dest, Block StmtM C C) 
                 -> (ChangeFlag, ProgM C C)
    removeOrphan live (flag, prog) (dest, block) 
      | dest `Set.member` live = (flag, blockGraph block |*><*| prog)
      | otherwise = (SomeChange, prog)
  \end{code}
  \caption{Our function which removes any block not referenced elsewhere in the program.}
  \label{ref_figure_removeOrphan}
\end{figure}

\section{Reflection}
\emph{What was good, what didn't work so well, and how Hoopl helped
or hindered the implementation}

Unfortunately, Hoopl's rewrite capability cannot eliminate
blocks altogether. 


\end{document}
