CHAPTERS = frontmatter \
           languages \
           deadcode \
           introduction \
           uncurrying \
           dataflow \
           mil

clean: extracleans

.PHONY: extracleans
extracleans:
	rm -f *.f.tex
	rm -f *.dvi
	rm -f *.fls
	rm -f *.ptb

# .tex files common to everyone.
COMMONTEX = preamble.tex document.preamble.tex 

# Make <chapter>.f.tex out of <chapter>
CHAPTERFS = $(addsuffix .f.tex, $(CHAPTERS))

# Make <chapter>.pdf out of <chapter>
CHAPTERPDFS = $(addsuffix .pdf, $(CHAPTERS))

allpdfs: thesis.pdf $(CHAPTERPDFS)

thesis.pdf: thesis.f.tex $(CHAPTERFS)
	-pdflatex -interaction=batchmode -jobname="thesis" thesis.f.tex
	-rm -f "thesis.pdf"
	-pdflatex -interaction=batchmode -jobname="thesis" thesis.f.tex

# Dead-code chapter includes some literate haskell, so 
# it gets its own rule.
deadcode.f.tex: deadcode.tex $(COMMONTEX) Live.lhs DeadBlocks.lhs

# Chapters that include subordinate files need their
# own rules generaelly.
languages.f.tex: languages.tex machLamComp.tex $(COMMONTEX)
mil.f.tex: mil.tex lst_mil1.tex lst_mil2.tex mil_syntax.tex $(COMMONTEX)
dataflow.f.tex: dataflow.tex lst_back1.tex lst_back2.tex lst_back3.tex lst_back4.tex lst_back5.tex \
                lst_back7.tex lst_back6.tex fig_back7.tex $(COMMONTEX)

# Compiles <chapter>.f.tex for <chapter>.pdf.  Works for chapters that
# only depend on common files.
#
# This is a "static pattern" rule.
$(CHAPTERPDFS): %.pdf: %.f.tex $(COMMONTEX)
	-pdflatex -interaction=batchmode -jobname="$(*F)" $<
	-rm -f "$(*F).pdf"
	-pdflatex -interaction=batchmode -jobname="$(*F)" $<

# All <chapter>.f.tex files are produced by running lhs2tex over
# <chapter>.tex.
#
# This is a "pattern" rule.
%.f.tex: %.tex 
	lhs2tex --poly -o $@ $<


