\documentclass[12pt]{report}
%include polycode.fmt
\include{preamble}
\begin{document}
\input{document.preamble}
\renewcommand{\textfraction}{0.1}
\renewcommand{\topfraction}{0.9}

\chapter{Dataflow Optimization}
\label{ref_chapter_background}

%% A short section giving the history of dataflow optimization techniques
%% and basic concepts.

The term \emph{program optimization} refers to the process of
transforming a program without changing its semantics (i.e., meaning),
while at the same time ``improving'' its behavior.  For example, an
optimized program may run faster, use less memory, or consume less
power.  Optimizations can be performed by hand, while writing the
program, or automatically by a compiler.

\emph{Dataflow analysis} (or \emph{dataflow optimization}), introduced
by Gary Kildall \citep{Kildall1973}, gives a framework in which many
different kinds of optimizations can be applied. He innovated by
describing a method for applying optimizations \emph{in general}, not
by describing a specific optimization.  We informally describe the
dataflow algorithm here. For a more formal treatment, see
\citep{AhoXX}.

The dataflow algorithm analyses and transforms \emph{control-flow
  graphs}, a data structure for representing programs. The algorithm
associates each node in the graph with a set of \inE and \out
\emph{facts}, representing the portion of the program's state under
analysis. In a \emph{forwards} analysis, we compute \out from \inE. A
\emph{backwards} analysis does the opposite: \inE from \out.  In both
case, a \emph{transfer function} transforms one set of facts to the
other. When nodes have multiple predecessors (or successors), we
combine facts using a \emph{meet operator}. The algorithm computes
facts until reaching a \emph{fixed point}. The facts computed can be
used to \emph{rewrite} the control-flow graph, giving us an optimized
program. In some cases, we do not rewrite the graph, but use the
results of the analysis in a later optimization.

This chapter describes the concepts necessary to understand dataflow
analysis and gives an extended example to illustrate them
together. Section~\ref{sec_back1} describes control-flow
graphs. Control-flow graphs can be expressed in terms of basic blocks,
which we motivate in Section~\ref{sec_back3}. We discuss facts,
direction, the transfer function and the meet operator in Section
\ref{sec_back4}. We illustrate why dataflow must be an iterative
algorithm (and define what a fixed point means in this context) in
Section~\ref{sec_back6}. We treat rewriting in
Section~\ref{sec_back7}. To demonstrate these concepts together, we
demonstrate \emph{dead-code elimination} in Section~\ref{back_2}.

\section{Control-Flow Graphs}
\label{sec_back1}

%% Begin by placing the specific concept in the overall context of
%% dataflow. Give a small example highlighting the concept. Point
%% out fine points or subtleties that occur when generalizing the concept. End
%% by summarizing how the concept fits into dataflow (in a bit larger
%% sense than the first summary).

Figure~\ref{fig_back1} shows a simple C program and its
\emph{control-flow graph} (CFG). Each \emph{node} in \subref{fig_back1_b} 
represents a statement or expression in the original program. For
example, \refNode{lst_back2_assigna} and \refNode{lst_back2_assignb}
represent the assignment statements on line
\ref{lst_back1_assign}. Notice that the declaration of #c# does not
appear in a corresponding node. Because the declaration does not cause
a runtime effect, we do not represent it in the graph.  Nodes \entryN
and \exitN designate where program execution \emph{enters} and \emph{leaves}
the graph. If the graph represented the entire program, we would say
execution \emph{begins} at \entryE and \emph{terminates} at \exitN. However, the CFG
may be embedded in a larger program, for which reason we say
\emph{enters} and \emph{leaves}.

\begin{myfig}[th]
\begin{tabular}{cc}
\subfloat{\input{lst_back1}%%
  \label{fig_back1_a}} \vline & 
\subfloat{\input{lst_back2}%%
  \label{fig_back1_b}} \\
\subref{fig_back1_a} & \subref{fig_back1_b} 
\end{tabular}
\caption{\subref{fig_back1_a} A C-language program fragment. \subref{fig_back1_b} The
  \emph{control-flow graph} (CFG) for the program.}
\label{fig_back1}
\end{myfig}

Directed edges show the order in which nodes execute. The edges
leaving \refNode{lst_back2_test} (representing the test
``\verb=if(a > b)='' on line \ref{lst_back1_test}) show that execution
can branch to either \refNode{lst_back2_true} (when $a > b$) or
\refNode{lst_back2_false} (when $a \leq b$). A node followed by
multiple successors (i.e., where multiple edges leave the node)
represents a \emph{branch} or \emph{conditional} statement. Any one of
the successor nodes may execute following the conditional statement.

The dataflow algorithm approximates a program's runtime state by
analyzing the control flow of the program. CFGs show the order in
which expressions and statements in a program are evaluated. The
dataflow algorithm intimately depends on the program representation
provided by the CFG.

\section{Basic Blocks}
\label{sec_back3}

%% Begin by placing the specific concept in the overall context of
%% dataflow. Give a small example highlighting the concept. Point
%% out fine points or subtleties that occur when generalizing the concept. End
%% by summarizing how the concept fits into dataflow (in a bit larger
%% sense than the first summary).

\begin{myfig}[th]
\begin{tabular}{ccc}
\begin{minipage}[b]{1.5in}
  \subfloat{\input{lst_back3}\label{fig_back4_a}}
\end{minipage} & %%
\begin{minipage}[b]{1.5in}
  \subfloat{\input{lst_back4}\label{fig_back4_b}}
\end{minipage}& %%
\begin{minipage}[b]{1.5in}
  \subfloat{\input{lst_back5}\label{fig_back4_c}}
\end{minipage} \\
\subref{fig_back4_a} & \subref{fig_back4_b} & \subref{fig_back4_c} \\
\end{tabular}
\caption{\subref{fig_back4_a}: A C-language fragment to illustrate
  \emph{basic blocks}.  \subref{fig_back4_b}: The CFG for
  \subref{fig_back4_a} without basic blocks. \subref{fig_back4_c}: The
  CFG for \subref{fig_back4_c} using basic blocks.}
\label{fig_back4}
\end{myfig}

%% Basic blocks
Consider the C-language fragment and CFGs in Figure~\ref{fig_back4}. 
Part~\subref{fig_back4_b} shows the CFG for part~\subref{fig_back4_a}: a long, straight sequence of nodes, one after
another. Part~\subref{fig_back4_C}, however, collapses all those nodes
into~\refNode{lst_back5_assign}. Our graph of statements becomes a
graph of \emph{blocks}.

Part~\subref{fig_back4_c} represents the assignment statements on
lines~\ref{lst_back3_start} -- \ref{lst_back3_end} as a \emph{basic
  block}: a sequence of statements with one entry, one exit, and no
branches in-between. Execution cannot start in the ``middle'' of the
block, nor can it branch anywhere but at the end of the block. In fact,
Part~\ref{fig_back4_b} also shows four basic blocks -- they just happen
to consist of one statement each.

The representation given in Part~\subref{fig_back4_c} has a number of
advantages. It tends to reduce both the number of nodes and the number
of edges in the graph. The dataflow algorithm maintains two sets of
\emph{facts} for every node -- reducing the number of nodes obviously
reduces the number of facts stored. The algorithm also iteratively
propagates facts along edges -- so reducing the number of edges
reduces the amount of work we need to do. When rewriting, blocks allow
us to move larger amounts of the program at once. It also can be shown
(see \citep{AhoXX}) that we do not lose any information by collapsing
statements into blocks. For efficiency and brevity, we will work with
basic blocks rather than statements from here forward.


\section{Facts, Transfer Functions, Direction \& The Meet Operator}
\label{sec_back4}

%% Begin by placing the specific concept in the overall context of
%% dataflow. Give a small example highlighting the concept. Point
%% out fine points or subtleties that occur when generalizing the concept. End
%% by summarizing how the concept fits into dataflow (in a bit larger
%% sense than the first summary).

\begin{myfig}[th]
\centering
\input{lst_back7}
\caption{The CFG for the C-language fragment from
  Figure~\ref{fig_back1_a}, annotated with \emph{facts} about the
  value of \texttt{a}, \texttt{b}, and \texttt{c} before (``\inBa'') and
  after (``\outBa'') each node.}
\label{fig_back5}
\end{myfig}

The dataflow algorithm computes two sets of \emph{facts} for every
node in the CFG. Facts are a data structure that describe the state of
the program before and after execution of the block represented by the
node. Figure~\ref{fig_back5} annotates the program fragment in
Figure~\ref{fig_back1} with facts about #a#, #b#, and #c# (the only
state we care about in this program). Each \inBa gives the variables'
values just prior to executing block $B$, while each \outBa gives
their values just after $B$ has executed.  

Figure~\ref{fig_Back5} shows a \emph{forwards} analysis, where \outBa
is computed from \inBa, for each block. Facts are created by a
\emph{transfer function} that inspects the statements in each node and
updates values assigned to variables, if any. Sometimes a dataflow
analysis will run \emph{backwards}, computing \inBa from
\outBa. Section \ref{sec_back2} gives a detailed example illustrating
a \emph{backwards} analysis. In general, the transfer function and
direction vary depending on the particular analysis performed.

To help define our transfer function, we define |valueOf|,
which either returns the value assigned to a variable, or its value
from \inBa:
\begin{equation} |valueOf|(v) = 
  \begin{cases}
    |assign|(v) & \text{when $v$ is assigned a value in the node,} \\
    \text{\inBa}(v) & \text{when $v$ is not assigned.} 
  \end{cases}
\label{eqn_back2}
\end{equation}
In the above, $v$ represents a variable; |assign| retrieves the value
assigned to that variable, if any.  Our transfer function just needs
to apply |valueOf| to all variables in \inBa, as well as all
variable assignments in the node itself. If |assigned| is the set of
all assigned variables in the node, we can define how our transfer
function relates \inBa and \outBa using set notation:
\begin{equation}
  \text{\outBa} = [|valueOf|(v) || v \in (\text{\inBa} \cup |assigned|)].
\end{equation}

Our initial fact, \inB{lst_back7_assign}:~\facts{a/\top, b/\top,
  c/\top}, assigns the value ``$\top$'' (``top'') to all variables,
indicating that we do not know the value for the given variable. Our
transfer function determines that \outB{lst_back7_assign} should be
\facts{a/1, b/2, c/\top}, showing that we know #a# is 1, #b# is 2, and
that we still do not know the value of #c#. At each block we perform a
similar analysis, except \refNode{lst_back7_print}, where we need to
  take special action.

When a node has multiple predecessors, like \refNode{lst_back7_print},
we must combine multiple \outB values into a single \inB. The value
for #c# in \outB{lst_back7_true} is 4, while in \outB{lst_back7_false}
#c# is 3. We have two distinct values for #c# and no way to determine
which will be the case when \refNode{lst_back7_print} executes. We
must be conservative, so we assign the value $\top$ to #c# in
\inB{lst_back7_print}.

\begin{table}[tbh]
  \centering
  \figbegin
  \begin{math}
    \begin{array}{ccccc}
      & v_1 & v_2 & v_1 \lub v_2 \\
      \cmidrule(r){2-2}\cmidrule(r){3-3}\cmidrule(r){4-4}
      1. & \top & v_2 & \top & \\ 
      2. & v_1 & \top & \top & \\
      3. & v_1 & v_2 & \top & \text{($v_1 \neq v_2$)}\\
      4. & v_1 & v_1 & v_1 
    \end{array}
  \end{math}
  \caption{How the meet operator used in
    Figure \ref{fig_back5} combines facts. $v_1$ and $v_2$ are
    values given by separate \outBa facts to the same variable. The
    table shows how they are combined.}
  \label{tbl_back2}
  \figend
\end{table}

A \emph{meet operator} defines how we combine facts when values
conflict. Table~\ref{tbl_back2} defines ``\lub'' (``least upper
bound'' or ``lub''), which combines values as we did for
\outB{lst_back7_true} and \outB{lst_back7_false}. $v_1$~and $v_2$
represent values given to the same variable by different
facts. Lines~1 and 2 show that when either value is $\top$, the result
is $\top$. When values differ, as in Line~3, again the result is
$\top$. Only when values are equal, as shown in the last line, do we
preserve the value.

Facts define the state of the program that we are analysing. The
transfer function transforms input facts into output facts. In a
forwards analysis, input facts come from predecessor nodes and output
facts flow to successors. For a backwards analysis, the opposite
occurs. When multiple facts need to be combined, we use a meet
operator. Each of these elements will vary depending on the specific
analysis performed.

\section{Iterative Analysis}
\label{sec_back6}
%% Begin by placing the specific concept in the overall context of
%% dataflow. Give a small example highlighting the concept. Point
%% out fine points or subtleties that occur when generalizing the concept. End
%% by summarizing how the concept fits into dataflow (in a bit larger
%% sense than the first summary).

As we saw in Figure \ref{fig_back5}, facts can conflict when nodes
have multiple predecessors. Even more complicated situations arise
when a program contains loops. Consider the fragment in
\ref{fig_back6}. To compute \inB{lst_back9_test}, we need
\outB{lst_back9_assign} and and \outB{lst_back9_incr}. To compute
\inB{lst_back9_incr} (in order to find \outB{lst_back9_incr}, we need
\outB{lst_back9_test}. But to compute \outB{lst_back9_test} we need
\inB{lst_back9_test}.  How do we apply our |valueOf| function
(Equation \ref{eqn_back2}) to a \refNode{lst_back9_test} when
\inB{lst_back9_test} depends on \outB{lst_back9_test}?

\begin{myfig}
\begin{tabular}{cc}
  \subfloat{\input{lst_back8}%%
    \label{fig_back6_a}} \vline &%%
  \subfloat{\input{lst_back9}%%
    \label{fig_back6_b}} \\ 
  \subref{fig_back1_a} & \subref{fig_back1_b}
\end{tabular}
\caption{\subref{fig_back6_a}: A simple C-language program with a loop. \subref{fig_back6_b}: The CFG 
for the fragment.}
\label{fig_back6}
\end{myfig}

We solve this problem by applying our transfer function
\emph{iteratively}. In the case of Figure \ref{fig_back6}, we first
initialize each all \inB and \outB facts to some default. We then use
|valueOf| to compute each \outBa. Of course, facts will change over
the course of iteration -- especially in the case of node
\ref{lst_back9_test}. We keep iterating until we reach a \emph{fixed
  point}, meaning the facts stop changing.

\begin{table}
  \centering
  \begin{math}
    \begin{array}{lcccc}
      \mathit{Iteration} & \outB{lst_back9_assign} & \outB{lst_back9_incr} & \inB{lst_back9_test} & \outB{lst_back9_test} \\
      \cmidrule(r){1-1}\cmidrule(r){2-5} 
      0 & \bot & \bot & \bot & \bot  \\
      1 & 0 & 10 & \bot & \bot \\
      2 & 0 & 10 & \bot & \bot \\
      \multicolumn{5}{c}{\dots} \\
      \multicolumn{5}{l}{\inB{lst_back9_test} = \outB{lst_back9_assign} \lub \outB{lst_back9_incr}} \\
    \end{array}
  \end{math}
  \caption{Iterative analysis of the CFG from Figure
    \ref{fig_back6}. We how the inputs used to calculate
    \outB{lst_back9_test} change in one iteration. The zeroth
    iteration represents the initial values given to \inBa and \outBa
    for all nodes.}  
  \figend
  \label{tbl_back3}
\end{table}

Table \ref{tbl_back3} shows \inE and \out for
\refNode{lst_back9_test}. To compute \inB{lst_back9_test}, we combine
\outB{lst_back9_assign} and \outB{list_back9_incr} using the meet
operator from Section~\ref{sec_back4}:
\begin{equation}
  \inB{lst_back9_test} = \outB{lst_back9_assign} \lub \outB{lst_back9_incr}.
\end{equation}
The zeroth iteration shows the initial
value for all sets. On the first iteration, we can see \inB{lst_back9_test} is $\bot$:
\begin{equation}
  \begin{split}
    \inB{lst_back9_test} &= \outB{lst_back9_assign} \lub \outB{lst_back9_incr} \\
    &= \bot \lub \bot \\
    &= \bot.
  \end{split}
\end{equation}
When computing \inBa, we always use \outBa from the
\emph{previous} iteration. In the above we use $\bot$ for \outB{lst_back9_incr} and
\outB{lst_back9_assign}. 

When computing \inB{lst_back9_test} in the second iteration,
\outB{lst_back9_incr} is 10 and \outB{lst_back9_assign} is
0. According to our meet operator, \inB{lst_back9_test} still equals
$\bot$:
\begin{equation}
  \begin{split}
    \inB{lst_back9_test} &= \outB{lst_back9_assign} \lub \outB{lst_back9_incr} \\
    &= 0 \lub 10 \\
    &= \bot.
  \end{split}
\end{equation}
At this point, our facts have stopped changing so we stop
iterating. Our final result $\bot$ for #c# in \outB{lst_back9_test}.

\section{Rewriting}
\label{sec_back7}

%% Begin by placing the specific concept in the overall context of
%% dataflow. Give a small example highlighting the concept. Point
%% out fine points or subtleties that occur when generalizing the concept. End
%% by summarizing how the concept fits into dataflow (in a bit larger
%% sense than the first summary).

Direction, the meet operator, facts, and the transfer function
together define a particular dataflow analysis. We can use the result
of the analysis to alter, or ``rewrite,'' the CFG of the program. The
meaning of the program should not change, but it should behave
differently: execute faster, use less memory, or whatever
characteristic the optimization should improve.  We do not have to
rewrite, of course. In some cases, we use the analysis to drive later
optimizations, or to report errors to the programmer. For example, a
\emph{reaching definitions} \citep{AhoXX} analysis can warn if
variables are used without being initialized. However, in most cases
we do want to rewrite the CFG.

\section{Example: Dead-Code Elimination}
\label{sec_back2}

Consider Figure \ref{fig_back2}, again showing a C-language fragment.
After its assignment on line \ref{fig_back2_dead_line}, #b# is not
referenced. Removing the #b# will not affect the meaning of the
program and, at least, will reduce the size of the program. It may
even make it run faster or use less memory. We call this optimization
\emph{dead-code elimination}.

\begin{myfig}[ht]
\begin{minipage}{1in}
  \begin{AVerb}[numbers=left]
    a = 1;
    if(rnd() > 1)
      b = a + 1;\label{fig_back2_dead_line}
    else
      b = a - 1;
    return a + 1;
  \end{AVerb}
\end{minipage}
\caption{A C-language fragment illustrating \emph{dead code}. After
assignment on line \ref{fig_back2_dead_line}, \verb=b= is not used
and can be considered ``dead.''}
\label{fig_back2}
\end{myfig}

Of course, people do not normally write programs with such obviously
useless statements, but other compiler optimizations can produce (or
leave behind) many such statements. \emph{Uncurrying}, described in
Chapter \ref{ref_chapter_uncurrying}, in fact depends on dead-code
elimination.

To eliminate the assignment like that on line
\ref{fig_back2_dead_line}, we really need to determine which variables
are referenced after assignment. Such variables are ``live''; if a
variable is \emph{not} live, then it is dead. We use this ``liveness''
analysis to determine if a particular assignment is dead.

To determine if a variable is live, we need to know if it is
referenced after assignment. Such variables make up the \emph{the
  live set} which we can compute between each statement. To compute
the live set, we can choose to traverse the CFG for the program
forwards or backwards.  In the forwards case, we must track each
assignment and determine, when we exit the CFG, if the variable was
used afterwards. In general we would need to track every assignment
until our traversal finished. However, if we traverse backwards, we
only need any variable references to the live set. When we see an
assignment to a variable \emph{not} in our live set, we know it has
never been referenced. Therefore we compute ``liveness'' using a
backwards traversal over the CFG.

\begin{myfig}[th]
\begin{minipage}{2in}
\input{lst_back10}
\end{minipage}
\caption{The CFG for our example program, annotated with the live
set for each node.}
\label{fig_back3}
\end{myfig}

Figure \ref{fig_back3} shows the CFG for this example. Annotations
show the facts we will compute: the live set before and after. Though
execution follows the arrows in the CFG, our analysis proceeds
backwards. For example, the input to node 2 is the live set computed
for node 3 (``$\{a\}$'' in this case).

Our transfer function computes the live set based on \emph{uses} and
\emph{definitions} in a statement. Any reference (or use) of a
variable goes into the live set. Any assignment (or definition) of a
variable removes it from the live set. We can then define our transfer
function, |live|, for a statement as:

\begin{align}
  & |live|(s) = (\Varid{in}(s) \cup |use|(s)) - |def|(s), \label{eqn_back1} \\
\intertext{where}
  & s     & \text{Statement considered.} \notag\\
  & |use|(s) &  \text{Set of variables used in $s$}. \notag\\
  & |def|(s) & \text{Variable assigned to in $s$ (a singleton set)}. \notag\\
  & \mathit{in}(s) & \text{Live variables computed for $s$' successor}. \notag
\end{align}

Table \ref{tbl_back1} shows the |use| and |def| sets for each
statement. The live set computed, |live|, becomes the input, \mathit{in}, for
the statement's predecessor. We include the exit node (``#X#'') in the
table to show the initial value of \mathit{in} for the last statement --
$\emptyset$, the empty set. Our analysis then works backwards through the
program. If our program (and its CFG) contained any loops, we would
need to run this algorithm multiple times, until the live set for each
statement reached a fixed point.

\begin{table}
  \centering
  \begin{tabular}{lcccc}
    $s$ & $|use|(s)$ & $|def|(s)$ & $\mathit{in}(s)$ &  $|live|(s)$ \\
    \cmidrule(r){1-1}\cmidrule(r){2-2}\cmidrule(r){3-3}\cmidrule(r){4-4}\cmidrule(r){5-5}
    #X# & & & & $\emptyset$ \\
    #return a + 1# & $\{a\}$ & $\emptyset$ & $\emptyset$ & $\{a\}$ \\
    #b = a + 1# & $\{a\}$ & $\{b\}$ & $\{a\}$ & $\{a\}$ \\
    #a = 1# & $\emptyset$ & $\{a\}$ & $\{a\}$ & $\emptyset$ \\
    \bottomrule
  \end{tabular}
  \caption{The $|use|$, $|def|$ and $|live|$ sets computed using equation \ref{eqn_back1} for our example program.}
  \label{tbl_back1}
\end{table}

With the live set computed for each statement, our analysis can now
determine which statements to eliminate. Only nodes 1 and 2 in Figure
\ref{fig_back3} perform an assignment. The live set for node 1 (``#a = 1#'')
contains #a#, so we do not eliminate it. In node 2 (``#b = a + 1#''),
the live set does \emph{not} contain #b#. Therefore, we can eliminate
node 2, giving us a new program without any dead code:

\begin{Verbatim}
a = 1;
return a + 1;
\end{Verbatim}

\section{Summary}
\label{sec_back9}

This chapter gave an overview of \emph{dataflow optimization}. The
dataflow \emph{algorithm} gives a general technique for applying an
\emph{optimizing function} to the \emph{control flow graph} (CFG)
representing a given program. The optimizing function computes
\emph{facts} about each node in the graph, using a \emph{transfer}
function. A given analysis can proceed \emph{forwards} (where \inBa
facts produce \outBa facts) or \emph{backwards} (where \outBa facts
produce \inBa facts). Each optimization defines a specific \emph{meet
  operator} that combines facts for nodes with multiple predecessors
(for forwards analysis) or successors (for backwards). We compute
facts\emph{iteratively}, stopping when they reach a \emph{fixed
  point}. Finally, we \emph{rewrite} the CFG using the facts computed. The 
meaning of our program does not change, but its behavior will be ``better,'' 
whatever that means for the particular optimization applied.


%% \subsection{Basic Blocks and Control-Flow Graphs}

%% A dataflow optimization operates over a ``control-flow graph'' (CFG)
%% of the program -- a directed graph where edges encode branches or
%% jumps and nodes represent statements. Programs run by entering a node
%% from a predecessor, executing the statements in turn, and exiting the
%% node to a successor. Multiple successors imply a conditional branch,
%% though the program can only choose one. A special ``entry'' node, with
%% no predecssors, exists to give the program a starting point.

%% The statements in each node must define a ``basic block,'' which means
%% there can only be one entry and one exit to the node. Each
%% predeccessor starts at the same statement; execution cannot start in
%% the ``middle'' of the statements in the node. Each successor also
%% leaves from the same instruction, so only one ``branch'' can exist in
%% each node.

%% For example, consider the ``fall-through'' implied by the use of #case#
%% statements in this C-language program fragment:

%% \begin{verbatim}
%%   switch(i) {
%%   case 1:
%%     printf("1");
%%     break;
%%   case 2:
%%     printf("2");
%%   case 3:
%%     printf("3");
%%   }
%% \end{verbatim}

%% \begin{figure}[h]
%% \begin{verbatim}
%%    A
%%   switch   ----<-
%%   | |  |  |      |
%%   | |  |  v C    ^
%%   | |   ->case 3 |
%%   | |     |      |
%%   | |      ->----_--
%%   | | B          |  |
%%   |  ->case 2 ->-   v
%%   |                 |
%%   |   D       ----<-
%%    ->case 1  |
%%      |       v
%%      v       |
%%    --+-----<-
%%   |
%%    -> ...
%% \end{verbatim}
%% \caption{CFG illustrating \emph{fall-through} allowed by the
%%   C-language \texttt{switch} statement.}
%% \label{switchCfgEg}
%% \end{figure}

%% Figure \ref{switchCfgEg} shows a CFG for this fragment. Execution
%% begins at node A. Node C has two predeccessors: A and B. The edge
%% between Node B and C represents fall-through from the second to third
%% case. They cannot be combined because the node would need two distinct
%% entry points. Encoding a program into basic blocks usually involves
%% inserting similar branches. The CFG makes explicit control--flow that
%% exists by implication in the source program.

%% \subsection{Direction, Facts and Rewrites}

%% \subsection{Example: Bind/Return Collapse}

%% Dataflow optimizations transform the CFG representation of a program,
%% with the goal of making a faster (or smaller, or more efficient, etc.)
%% program. Dataflow computes a set of ``entry'' assumptions and ``exit''
%% facts for each node in the graph. Facts for one node become
%% assumptions for the nodes' successors (thus the term
%% ``dataflow''). The algorithm iteratves over the entire graph until a
%% fixed point is reached -- that is, facts and assumptions no longer
%% change. The computed facts can then be used to transform the graph.

%% \emph{Constant propagation example -- or something more functional?}

%% \emph{Introduce forward and backwards dataflow.}

% What does dataflow mean?

% How do you use it?

% Example

\end{document}

% LocalWords:  Dataflow dataflow CFG printf variable's CFGs ccc Uncurrying
% LocalWords:  liveness
