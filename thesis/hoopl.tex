\documentclass[12pt]{report}
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
\input{preamble}
\begin{document}
\input{document.preamble}
\chapter{The Hoopl Library}
\label{ref_chapter_hoopl}

%% Introduction ...

The Hoopl library \citep{Hoopl-3.8.7.0}, written in Haskell, provides
a framework for implementing optimizations using the dataflow
algorithm. It does not target a particular programming language or
provide specific optimizations; rather, it enables the user to
implement their own optimizations for their own language. A
thorough description of the implementation of the library can be found
in the authors' paper \citep{Ramsey2010}; here, we discuss the
abstractions they provide and how to use Hoopl when implementing
dataflow-based optimizations.

%% Broad description of how Hoopl abstracts the dataflow algorithm

Hoopl applies a given optimization to a control-flow graph (CFG),
iteratively collecting facts (either forward or backward) until
reaching a fixed point. The library implements the generic portions of
the dataflow algorithm: iterative analysis, traversing the CFG, and
combining facts between blocks. The \emph{client program}, a term
Hoopl uses to mean a program implementing some optimization, provides
data structures and functions for that specific optimization: the
representation of facts, a transfer function, a meet operator such
that the facts can be placed in a lattice, and a rewriting function
that transforms the CFG.

%% Discuss Hoopl's implementation of the iterative analyze/rewrite
%% technique discussed in Lerner's paper.

%% TODO: Read the paper.
%% Hoopl diverges from standard dataflow analysis by implementing the
%% interleaved analysis and rewriting technique described in
%% \cite{Lerner2002}.

%% Introduce example

Throughout this chapter we will explain Hoopl concepts by implementing
a client program that performs \emph{dead-code elimination} for a very
small subset of the C language. Dead-code elimination removes
``useless'' statements from a program. The definition of ``useless''
varies according to programming language, hardware, and user intent,
but in all cases it implies that the semantics of the program do not
change.

Considering Figure \ref{hoopl_fig1}, we can see several
useless statements: the assignment to \texttt{a} on Line
\ref{hoopl_lst1_assign}, the test on Line \ref{hoopl_lst1_test}, and
the ``true'' branch on Line \ref{hoopl_lst1_test_true}. Any and all of
these can be removed without changing the meaning of the program ---
it will still print ``\texttt{3}'', but may run a little bit faster
and use less memory. 

\begin{myfig}
\begin{minipage}[b]{2in}
\begin{AVerb}[numbers=left]
int a = 1, c; \label{hoopl_lst1_assign}

if(1 > 2) \label{hoopl_lst1_test}
  c = 4; \label{hoopl_lst1_test_true}
else     
  c = 3; \label{hoopl_lst1_test_false}

print(c); \label{hoopl_lst1_print}
\end{AVerb}
\end{minipage}
\caption{A C-language fragment that will be used to demonstrate
  \emph{dead-code elimination}.}
\label{hoopl_fig1}
\end{myfig}

%% Provides signposts for chapter.

In Section \ref{hoopl_sec1}, we describe Hoopl's abstractions, showing
the Haskell types, data structures, and function signatures provided
by the library. Throughout, we develop our client program to implement
dead-code elimination and show how it optimizes the program in Figure
\ref{hoopl_fig1}. Section \ref{hoopl_sec2} shows how Hoopl influenced
the implementation the MIL language from Chapter \ref{ref_chapter_mil}
and discusses the design choices we made. We conclude with a summary
and brief discussion of our experience with Hoopl in Section
\ref{hoopl_sec3}.

\section{Hoopl's Representation of the Dataflow Algorithm}
\label{hoopl_sec1}

%% Hoopl parameters: Hoopl-defined structures

In order to implement dataflow analysis generically, Hoopl defines
several core data structures which client programs must use. These
include: the representation of CFGs, the type of transfer and rewrite
functions, and the represention of the meet operator. Hoopl controls
the CFG representation so it can traverse, rewrite, and propagate
facts around the CFG. Hoopl specifies the type of the transfer and
rewrite function such that they produce useable information (and
rewrites). Finally, Hoopl specifies the meet operator (but not its
implementation) so that the library can find fixpoints.

%% Hoopl parameters: User-defined structures

Hoopl requires that client programs specify those items related to
their specific optimization: the abstract syntax tree (AST) of the
language, the representation of facts, and the implementation of the
transfer and rewrite functions. Each node in the CFG typically
contains an expression or statement from the client programs
AST. While Hoopl controls the edges between nodes in the CFG, it does
not specify the contents of those nodes. Similarly, while Hoopl
determines when the analysis reaches a fixpoint, it requires that the
client specify when one set of facts equals another. Finally, Hoopl
applies the transfer and rewrite functions to the CFG but requires
that the client program implement them for their specific AST and
optimization.

\subsection*{Control-Flow Graphs}

Hoopl defines CFGs in terms of \emph{successors} and
\emph{predecessors}. Additionally, Hoopl parameterizes blocks as
\emph{open} or \emph{closed} on entry and exit. Roughly, ``open''
means control-flow enters the block. ``Closed'' means control-flow
branches from the block. As open and closed apply to both entry and
exit, we write them as ``open/open'', ``open/closed'',
``closed/open,'' and ``closed/closed.''
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\;\Conid{Graph}\mathrel{=}\Conid{Graph'}\;\Conid{Block}{}\<[E]%
\\
\>[3]{}\mathbf{data}\;\Conid{Block}\;\Varid{n}\;\Varid{e}\;\Varid{x}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\ellipsis{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\mathbf{data}\;\Conid{Graph'}\;\Varid{block}\;\Varid{n}\;\Varid{e}\;\Varid{x}\;\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{GNil}{}\<[11]%
\>[11]{}\mathbin{::}\Conid{Graph'}\;\Varid{block}\;\Varid{n}\;\Conid{O}\;\Conid{O}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{GUnit}\mathbin{::}\Varid{block}\;\Varid{n}\;\Conid{O}\;\Conid{O}\to \Conid{Graph'}\;\Varid{block}\;\Varid{n}\;\Conid{O}\;\Conid{O}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{GMany}\mathbin{::}\Conid{MaybeO}\;\Varid{e}\;(\Varid{block}\;\Varid{n}\;\Conid{O}\;\Conid{C}){}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\to \Conid{LabelMap}\;(\Varid{block}\;\Varid{n}\;\Conid{C}\;\Conid{C}){}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\to \Conid{MaybeO}\;\Varid{x}\;(\Varid{block}\;\Varid{n}\;\Conid{C}\;\Conid{O}){}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\to \Conid{Graph'}\;\Varid{block}\;\Varid{n}\;\Varid{e}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
An ``open/open'' block can be
the successor of another block (i.e., it can be the target of a jump
or normal straight-line execution).  There may not be any predecessor,
of course. However, the same block must be the predecessor of another
block.

A closed on entry
block block can be the target of a jump; i.e., an open block can be
the successor of another block. A closed block cannot be the target of
a jump, but it can jump to one of many blocks; for example, a \ensuremath{\Varid{switch}}
statement in C can be represented as a closed block that could branch
to any of the case labels.

\subsection*{Facts and Lattices}

\subsection*{Transfer Functions}

\subsection*{Iteration \& Fixed Points}

\subsection*{Interleaved Analysis \& Rewriting}

\section{MIL and Hoopl}
\label{hoopl_sec2}

\subsection{MIL Statements, Tails, \& Shapes}

\section{Summary}
\label{hoopl_sec3}

\standaloneBib

\end{document}
