\documentclass[11pt]{article}
\usepackage{url}
\usepackage{fancyvrb}
\begin{document}

\begin{enumerate}
\item Define x86 instruction set in terms of sequential sequent calculus (SSC)

\item Use the calculus as a target for Habit compiler

\item SSC is equivalent to simply-typed lambda calculus. Is there a
  proof path from Habit to some extended version of SSC? Or,
  can SSC be expressed in a subset of Habit types? How to
  preserve certification chain?

\item Goal: implement Habit runtime directly in Habit, 
  including garbage collection. 
  
  Can reference counting operations
  be implemented directly in Habit? Do we know when a cell is no
  longer referenced?

\item Verifiable machine code using SSC. Define a means of specifying
  types/data structures in machine code. Verify that the program
  included respects the ytype annotations embedded in the program
  itself.  Proof-carrying code more or less?  Read ``type system for
  certified binaries.''
  
  \begin{enumerate}
    \item If Habit types map to SSC types, and machine-code is
      verifiable, then implementation of mapping doesn't need to be
      verififed, because both ends can be checked. Does type-checker
      for machine code need to be verified?
    \item Exercise -- how to represent the stack (ESP, EBP) in SSC?
      When a program executes does the OS set the initial value of
      stack pointer? How do you keep heap and stack from stomping on
      each other?
  \end{enumerate}
  
\item A verified compiler from MSIL to x86? Could also target MSIL, but seems silly
  since the CLR is already ``safe.''

\item Safe access to underlying native libraries from Javascript? E.g., Direct3D in
  the browser.
  \begin{enumerate}
  \item A javascript interpreter/compiler, suitable for use as a library. Hard since JavaScript
    barely has any types. More interesting to implement from ECMAScript 5?
  \end{enumerate}

\item post-hoc type signatures added to native libraries (using
  embedded machine-code types)?

\item Use \emph{data types a-la-carte} technique to represent/elaborate
  intermediate language parse trees. Use \emph{attribute grammars} to operate
  on those trees.

\item Transform Habit source into something more and more like machine code. Prove
  that all source transformations preserve types, and implement the compiler such
  that type information cannot be lost. Is it sufficient to store all intermediate
  source so it can be independently type checked? Must also be able to define an
  equivalence between a pure type and a more imperative ``monadic'' type. For example,
  to expose allocation when creating closures.

  Use \emph{state threads} to transform impure code to pure?

\item Compile various forms $\lambda$-calculus, introducing richer languages along the 
  way. Need to get to at least I/O effects. Can ``System Fw'' be implemented?

\item Is Go an interesting language to target? Explicitly C like, but
  ``safe.'' Can issues like atomic update be caught at the type level?
  The problem is described at
  \url{http://research.swtch.com/2010/02/off-to-races.html}.

\item How to type the swap function? 

  \begin{Verbatim}
    void swap(void * a, void * b)
    {
      void * t = a;
      b = a;
      a = t;
    }
  \end{Verbatim}

\item Read up on x86 floating point hardware and see why it's so hard to model.

\end{enumerate} 

\end{document}

