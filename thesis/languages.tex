\documentclass[12pt]{report}
%include polycode.fmt
%include lineno\lineno.fmt
\include{preamble}
\begin{document}
\input{document.preamble}

\chapter{The \LamA \& Functional Languages}
\label{ref_chapter_languages}

%% Overall: Justify why the lambda-calculus matters
%%   * Give syntax and evaluation rules for lambda-case
%%   * Set the foundation for MIL-to-LC later

John McCarthy created LISP, the first ``functional'' language, in 196X
\citep{McCarthyXX}. Other functional languages created since then
include Scheme, ML, Haskell, and many more. While syntax, semantics
and capabilities differ widely between all these languages, they 
share a common characteristic: \emph{the ability to manipulate
  functions as first-class values}.

A function that returns a function can be hard to get used to, so some
examples may help. First, we look at a function that just computes
a value -- it does not return a function or anything fancy.
Figure~\ref{lang_fig1} shows ``#mag#'', a function that doubles its value,
written in four different functional languages. 

\begin{myfig}[bth]
  \begin{tabular}{cc}
  \subfloat{%%
    \begin{minipage}{2in}\begin{withHsNum}%%
> mag :: Float -> Float {-"\label{lang_fig1_haskell_sig}"-}
> mag a = 2 * a {-"\label{lang_fig1_haskell_impl}"-}
    \end{withHsNum}\end{minipage}%%
    \label{lang_fig1_haskell}} & %%
  \subfloat{\input{lang_fig1_ml}\label{lang_fig1_ml}} \\

  \subref{lang_fig1_haskell} & \subref{lang_fig1_ml} \\

  \subfloat{\input{lang_fig1_scheme}\label{lang_fig1_scheme}} & %%
  \subfloat{\input{lang_fig1_js}\label{lang_fig1_js}} \\

  \subref{lang_fig1_scheme} & \subref{lang_fig1_js} 
  \end{tabular}
  \caption{Definitions of a function that doubles its argument in
    \subref{lang_fig1_haskell} Haskell, \subref{lang_fig1_ml} ML, 
    \subref{lang_fig1_scheme} Scheme, and \subref{lang_fig1_js} JavaScript.}
  \label{lang_fig1}
\end{myfig}

Part \subref{lang_fig1_haskell} gives the Haskell version. Haskell is
a statically typed language, so we begin with a type signature on
Line~\ref{lang_fig1_haskell_sig}: ``|mag :: Float -> Float|.'' This
signature indicates that |mag| takes an argument of type |Float| and
returns a result, also of type |Float|, where |Float| represents a
floating-point number
\citep{HaskellReportXX}. Line~\ref{lang_fig1_haskell_impl} implements
|mag|. The function name comes first, followed by the argument
(``|a|''). The right-hand side of the equals sign (``|=|'') defines
the \emph{body} of the function: ``|2 * a|.'' The body is evaluated
when the function is applied to an argument and a result must be
computed.\footnote{Haskell is a \emph{lazy} language, meaning no
  computations are performed until \emph{demanded}. Therefore, we say
  the body is evaluated only when a ``result must be computed.''}

Figure~\ref{lang_fig1}, Part~\subref{lang_fig1_ml}, gives the ML
implementation. ML is also statically typed, so we start with the type
signature on Line~\ref{lang_fig1_ml_sig}: ``#float -> float#.'' This
signature has much the same meaning as the Haskell
version. Line~\ref{lang_fig1_ml_impl} gives the implementation of
#mag#. The ``#*.#'' operator represents floating-point
multiplication. Otherwise, the implementation is much the same as the
Haskell version.

Figure~\ref{lang_fig1}, Part \subref{lang_fig1_scheme}, gives the
Scheme definition. Scheme is a dynamically typed language, so no
signature can be given -- just the implementation. The expression
``\texttt{define mag}\ \emph{expr}'' associates \emph{expr} with the
name ``#mag#.'' The expression in this case, ``\texttt{lambda (a)
  \ldots)},'' creates a new function that takes one argument, ``#a#.''
The body of the function, ``#(* 2 a)#,'' shows that the argument will
be doubled when the function is applied.

%% ``#define#'' keyword
%% associates a name with a value. The
%% ``#lambda#'' keyword indicates that a function will be created. The
%% funciton defined takes only one argument, designated ``#a#.'' The
%% postfix expression, ``#(* 2 a)#,'' defines the body of the function
%% and will be evaluated when the function is applied.

Figure~\ref{lang_fig1}, Part \subref{lang_fig1_js}, shows the
JavaScript version. Line~\ref{lang_fig1_js_def} gives the
\emph{signature} of the function -- the name of the function and any
named arguments. JavaScript is also a dynamically typed language, so
this is \emph{not} a type signature, but rather a specification of how
to call the function.\footnote{In JavaScript, functions can take more
  arguments than are declared, for which reason we say ``named''
  arguments here.}  Function definitions always start with the
``#function#'' keyword, followed by the function name and any
named arguments in parentheses: ``#mag (a)#''. The body of the function,
on Line~\ref{fig_lang1_js_impl}, uses the ``#return#'' keyword to
indicate the function doubles its argument and returns the resulting
value: ``#return 2 * a;#.''

The functions defined in Figure~\ref{lang_fig1} all have one thing in
common: they are limited to doubling their argument. If we want to
triple our argument, halve it, zero it or perform any other
multiplication, then we need to write a new function.

Of course, we can write a function that takes two arguments, the
multiplier and the argument. For example, in JavaScript:
\begin{AVerb}
function magBy(multiple, a) \{
  return multiple * a;
\}
\end{AVerb}
But this limits us from re-using ``#magBy#'' in certain ways. 

Imagine a function that wants to apply ``#magBy#'' to all items in a
list:\footnote{In this fragment, #items# is an array of values,
  accessed by index. We enumerate it using a #for# loop much like the
  that found in the C language.}
\begin{AVerb}
function magAll(items, multiple) \{
  for(var i = 0; i < items.length(); i++)
    items[i] = magBy(multiple, items[i]);
\}
\end{AVerb}
This definition creates two problems:
\begin{enumerate}
\item Every call to ``#magAll#'' requires us to specify a value for
  ``#multiple#.'' 
\item Our function is limited to using ``#magBy#.'' If ``#magBy#''
  isn't appropriate for some situation, we need to write a new
  ``#magAll#'' that uses a different version.
\end{enumerate}
We solve these two problems by making ``#magBy#'' a \emph{parameter}
to ``#magAll#.'' In pictures, we create a ``hole'' in ``#magAll#''
that we fill with code passed in:
\begin{AVerb}
function magAll(items, \emph{<code>}) \{
  for(var i = 0; i < items.length(); i++)
    items[i] = \emph{<code>};
\}
\end{AVerb}
The ``\emph{<code>}'' argument precisely illustrates how 
functional languages treat ``functions as values.''

Figure~\ref{lang_fig2} shows the definition of |multiplier| in the
same four languages as Figure~\ref{lang_fig1}, as well as a re-definition
of ``|mag|'' in terms of ``|multiplier|.'' When |multiplier| is
evaluated, it produces a value like any function; that value just
happens to be a function itself! The function returned takes an
argument and multiplies it by the original multiple given to
|multiplier|.

\begin{myfig}
  \begin{tabular}{cc}
    \subfloat{\begin{minipage}{3.5in}\begin{withHsNum} %%
> multiplier :: Float -> (Float -> Float)
> multiplier multiple = 
>   \a -> multiple * a {-"\label{lang_fig2_hs_fun}"-}
>
> mag :: Float -> Float
> mag = multiplier 2 {-"\label{lang_fig2_hs_mag}"-}
        \end{withHsNum}
      \end{minipage}\label{lang_fig2_hs}} & %%
    \subfloat{\input{lang_fig2_ml}\label{lang_fig2_ml}} \\

    \subref{lang_fig2_hs} & \subref{lang_fig2_ml} \\

    \subfloat{\input{lang_fig2_scheme}\label{lang_fig2_scheme}} & %%
    \subfloat{\input{lang_fig2_js}\label{lang_fig2_js}} \\

    \subref{lang_fig2_scheme} & \subref{lang_fig2_js} \\

  \end{tabular}
  \caption{The |multiplier| function and how it can be used to define
    |mag|. When evaluated, |multiplier| returns a function that
    will multiply its argument by |multiple|. We give
    \subref{lang_fig2_hs} Haskell, \subref{lang_fig2_ml} ML,
    \subref{lang_fig2_scheme} Scheme, and \subref{lang_fig2_js}
    JavaScript versions.}
  \label{lang_fig2}
\end{myfig}

Figure~\ref{lang_fig2}, Part~\subref{lang_fig2_hs} gives the Haskell
version of ``|multiplier|.'' The signature, ``|Float -> (Float ->
Float)|,'' shows that ``|multiplier|'' takes one argument, a ``|Float|''
value, and returns a function (``(|Float ->
Float)|''). Line~\ref{lang_fig2_hs_fun} creates an \emph{anonymous}
function: 

> \a -> multiple * a

The anonymous function is introduced with the ``|\|'' (``lambda'')
symbol, followed by one argument, ``|a|.'' The body of the function
follows the arrow (``|->|''). 
Notice that ``|multiple|'' is \emph{not} an argument to this
function. Instead, it is an argument to |multiplier|. We say
|multiple| is \emph{captured} by the anonymous function. The anonymous
function is the value returned by |multiplier|. When that value is
itself applied to an argument, it will use the value of |multiple|
originally given to |multiplier|.

On Line~\ref{lang_fig2_hs_mag} we use |multiplier| to define the
|mag| function from Figure~\ref{lang_fig2_hs}. The function has
the same signature, ``|Float -> Float|,'' but no argument:

> mag :: Float -> Float
> mag = multiplier 2

If we substitute the definition of
|multiplier| in |mag|, we can see the function |mag| represents:

\begin{math}
  \begin{array}{cc}
    |mag| &= |multiplier 2| \\
    &= |\a -> 2 * a | 
  \end{array}
\end{math}

Notice that the argument |a| appears on the right-hand
side here, for which reason |mag| does not specify an argument
in Figure~\ref{lang_fig2_hs}.

Figure~\ref{lang_fig2}, Part \subref{lang_fig2_ml} shows the ML
definition for #multiplier# and #mag#. \texttt{multiplier} returns
the value #f#, which is again a function. Line~\ref{lang_fig2_ml_fun}
defines #f# as a local, named function:

\begin{AVerb}
  let f a = a *. multiple
  in f
\end{AVerb}

Again, we capture the value of #multiple# when defining #f#. When #f#
is evaluated, it will multiply its argument by the #multiple#
given. The definition of #mag# on Line~\ref{lang_fig2_ml_mag} in terms
of #multiplier# looks almost exactly the same as the Haskell version.

In Figure~\ref{lang_fig2}, Part \subref{lang_fig2_scheme}, we give the
Scheme version of #multiplier# and #mag#. As in
Figure~\ref{lang_fig1_scheme}, the body of #multiplier# is a function,
defined using #lambda#. However, this function returns a function,
again defined with #lambda#:

\begin{AVerb}
  (lambda (a) (* multiple a))))
\end{AVerb}

As in the Haskell and ML versions, the inner function captures the
value of #multiple# given to the outer function. On
Line~\ref{lang_fig2_scheme_mag} we evaluate the expression
\texttt{({multiplier} 2)} and assign the result to #mag#:
\begin{AVerb}
  (define mag 
    (multiplier 2))
\end{AVerb}

Figure~\ref{lang_fig2}, Part \subref{lang_fig2_js} shows the JavaScript
version of #multiplier#. The body of #multiplier# returns an anonmous
function, defined using the #function# keyword without a function name:
\begin{AVerb}
  return function(a) \{ 
    return multiple * a;
  \};
\end{AVerb}

Once again, the #multiple# argument is captured and used by the
returned function. Line~\ref{lang_fig2_js_mag} shows how #mag#
is defined in terms of #multiplier#:

\begin{AVerb}
  var mag*.te = multiplier(2);
\end{AVerb}

The #var# keyword introduces an
identifier, to which we assign the function returned by
#multiplier(2)#. In some ways this syntax makes it most obvious that
we are treating functions as values.

Returning to #magAll#, we can redefine it to take a function argument:
\begin{AVerb}
function magAll(items, magnifier) \{
  for(var i = 0; i < items.length(); i++)
    items[i] = magnifier(i);
\}
\end{AVerb}
Here, #magnifier# is a function, passed as an argument. If 
we wish to double the items in the array, we just pass #double#
to #magAll#:
\begin{AVerb}
  magAll(items, double);
\end{AVerb}
To multiply the items however we need, we just create appropraite
\emph{function values} and pass them to #magAll#:
\begin{AVerb}
  var halve = multiplier(0.5);
  var quadruple = multiplier(4);
  magAll(items, quadruple);
  magAll(items, halve);
\end{AVerb}
We can even pass an \emph{anonymous function} directly to 
#magAll#, as here where we halve the values again:
\begin{AVerb}
  magAll(items, function (i) \{ return i * 0.5; \});
\end{AVerb}

%%  However, that value is itself a 
%% function. |multilp
%% evaluated, creates a new function. in our four languages

\section{Why \LamA?}
\label{lang_sec1_}

The \lamA really is the essential functional programming language.  
That does not mean it is the programming language anyone
should ever use outside research or theoretical settings. What it
means is the \lamA has everything you need to model the behavior
of other programming languages. 

Of course, you could say the same about any Turing-complete
language. What makes the \lamA special is its simplicity. Nothing is
built-in, not even the natural numbers. There is almost nothing to get
in the way of studying your particular domain, rather than fiddling
with the programming language.

Again, that could be said about any sufficiently simple
Turing-complete programming language. However, the \lamA is inherently
functional -- it can only define functions, and all values computed
are themselves functional. Translating from the \lamA to
another functional language is usually straightforward (or maybe your
target language isn't very functional). 

Its power, simplicity, and functional nature make the \lamA so popular
in functional language research, and motivate our own choice in using
it. We do not show how to compile a ``real-world'' functional language
to our intermediate language, but by showing how to compile the 
\lamA to our language, we show our technique could be used by ``real'' 
functional languages (with some adaptions, of course).

%% We will be demonstrating a number of dataflow optimizations over
%% our intermediate language programs, but all of our source programs will
%% be written in a variant of the \lamA. Any variante

%% A compilation technique demonstrated for
%% some variant of the \lamA can be translated into any other functional
%% programming language. Making the translation work well with the syntax
%% and semantics of the target language is still hard work, but
%% absolutely possible -- a result developed for the \lamA really is
%% universal (as far as you want to make use of that result, of course). 

%% It is these three reasons that make the \lamA such a popular
%% language for showing theoretic (or practical) results

%% This chapter introduces the \lamA calcus, giving its 

%% Most importantly, results obtained
%% using the \lamA are guaranteed to translate to other Turing-complete
%% languages -- and usually with better syntax! 

%% Being Turing-complete, the \lamA is capable of exeucting any program
%% you could write on a modern computer.  

%%  . What it does mean is that anything possible in the \lamA Being
%% Turing-complete, it can be

%% \emph{\ldots transition
%%   \ldots}. Most importantly, the \lamA serves as the \emph{lingua
%%   franca} for functional programmers. It provides a way to translate
%% between functional programming languages, and a way to carry
%% developments from one language to another. 

%% so its capabilities are
%% as powerful as any other Turing-complete programming language. 

%% Being Turing-complete, it can emulate any other
%% Turing-complete language. Its direct support for manipulating
%% functions-as-values makes it a good choice for emulating higher-level
%% functional languages.

%% It is not a language that you want to write many 
%% programs in, 

%% Its sparse syntax
%% and straightforward evaluation rules means their is less to worry about
%% when trying out new design ideas or theories.  . Most importantly, though, 


%% Figure~\ref{lang_fig1} defines
%% a function for adding two numbers in Scheme, ML, Haskell and JavaScript,
%% some of the more prominent functional languages in use today. 




 
%% 1. Relate lambda-calculus to functional langauges in general
%% 2. Define the lambda-calculus
%%    * syntax, semantics, evaluation rules
%% 3. Compliling - or better to move that to MIL chapter?

%% Informally, a \emph{function} is a mathematical definition that takes
%% arguments and computes some result. For example, \emph{plus1} just adds 1 
%% to its argument, using the normal rules of arithmetic:
%% \begin{equation}
%%   |plus1|\ x = x + 1.
%% \end{equation}
%% We are not limited to defining functions that add 1. Functions can
%% also be \emph{values} -- just as 1 or $x$ are in the expression
%% above. Here, we define a function, that returns a function, that always
%% adds 1:
%% \begin{equation}
%%   |adder1| = \lambda\ x = x + 1.
%% \end{equation}
%% In |adder1|, ``$\lambda\ x$'' indicates we return a function that takes one
%% argument. We can go further and define a function that, given an
%% argument, returns a function which always adds that amount:
%% \begin{equation}
%%   |adder|\ n = \lambda\ x = x + n.
%% \end{equation}
%% Notice how the outer argument $n$ gets ``captured'' by the body $x +
%% n$. Using $|adder|$, we can now re-define $|adder1|$ above:
%% \begin{equation}
%%   |adder1| = |adder|\ 1.
%% \end{equation}

%% Other functional languages created since then include 
%% Scheme, ML, Haskell, and many more. While syntax, semantics and capabilities
%% differ widely between all these languages, they all share the characteristic
%% shown above: \emph{the ability to manipulate functions as first-class values}.

\section{The \LamA}
%%\emph{Why is it important}

%%\emph{What is the \lamA}

Alonzo Church defined his \lamA (``lambda calculus'') in 19XX
\citep{ChurchXX} to study systems of recursive equations. Being
Turing-complete, it can be used to model the behavior of any
computational system. However, it is particularly useful for modeling
functional programming languages. %% why?

Figure \ref{lang_fig2} gives a syntax for the ``pure''
\lamA. ``Abstraction'' defines a new function, while ``application''
gives a particular argument to a function. ``Variables'' are defined
when mentioned. 

\begin{myfig}[ht]
  \begin{equation*}
    \begin{aligned}
      \mathit{term} &= a, b, \ldots & \text{\emph{(Variables})} \\
      &= \lamAbs{x}{t} & \text{\emph{(Abstraction)}} \\
      &= \lamApp{t}{t} & \text{\emph{(Application)}}
    \end{aligned}
  \end{equation*}
  \caption{The \lamA' syntax. A term can be a \emph{variable}, \emph{abstraction},
  or \emph{application}. When $t$ appears, it means a term can be substituted. Other
  letters stand for variables. In the case of \emph{abstraction}, $x$ always stands
  for a single variable.}
  \label{lang_fig2}
\end{myfig}

%%\emph{What does it look like?}

Using this syntax, we can define some common functions. |Identity|
returns its argument:
\begin{align}
  |identity| &= \lamAbs{x}{x}. \label{eq_lang2} \\
  \intertext{|Const| takes two arguments but always returns the first:}
  |const| &= \lamAbs{a}{\lamAbs{b}{a}}. \label{eq_lang4} \\
  \intertext{|Compose| takes two functions and an argument. The result of
    applying the second function to the argument is passed to the first:}
  |compose| &= \lamCompose. \label{eq_lang3} 
\end{align}
Note that function application is right-associative, meaning
\lamPApp{f}{\lamPApp{g}{x}} is the same as \lamApp{\lamApp{f}{g}}{x},
but \emph{not} the same as \lamPApp{\lamPApp{f}{g}}{x}.

\begin{myfig}[bt]
\begin{minipage}{2in}
\begin{Verbatim}
                ##  
                 #  
 ##  ## ## ###   #  
####  # ## ###   #  
#     ###  # #   #  
 ###   #   ## # ### 
\end{Verbatim}
\end{minipage}
  \caption{Evaluation rules for \lamA. These rules show 
    \emph{call-by-value}, where arguments are evaluated
    before functions.}
  \label{fig_lang2}
\end{myfig}

A \lamA term executes by rewriting the expression according to the
rules in Figure \ref{fig_lang2}. We match our term to each of the
patterns above the line. If we have a match, we rewrite according to
the pattern below the line. When no more matches can be made, we say
the term is in \emph{normal form}: we have finished executing.

The rules given implement \emph{call-by-value} evaluation order,
meaning arguments to a function are evaluated before the function
itself. Other variants include \emph{call-by-need} and
\emph{call-by-name}, where arguments are not evaluated until
needed. We do not considers those variants further, however.

\section{Compiling the \LamA}
\label{sec_lang1}

%% Define which steps in compilation we're going to worry about
Compiling even a language as simple as the \lamA involves a number of
steps, such as defining a concrete syntax, parsing source programs
into an abstract syntax tree (AST), and producing an executable
program from the AST. For our purposes, however, we just focus on the
\lamA' three fundamental operations:

\begin{itemize}
\item Naming values (\emph{variables}).
\item Apply a function to an argument (\emph{application}).
\item Create a new function (\emph{abstraction}). 
\end{itemize}

Any compiler for the \lamA must be able to produce executable programs
which implement these operations. 

%% \subsection{The Target Machine}
%% We begin by defining a \emph{target machine}, |M|, for our compiler. To
%% reduce complexity we do not target an actual computer, but one of our
%% own design. Our machine will have an infinite number of
%% \emph{registers} (i.e., storage locations) that we can refer to by
%% name. It will have an unlimited supply of memory (called the
%% \emph{heap}) in which we can allocate structured values. However, we
%% will not refer to memory locations directly. Instead, we will always
%% store references to heap values in registers. Finally, the machine
%% will execute a list of instructions (our \emph{program}), starting at
%% the beginning and proceeding in sequential order (unless otherwise
%% instructed), until reaching the end of the list. Each instruction will
%% have a definite location, but we will only refer to certain special
%% locations using named labels.

%% \subsection{M's Language: \machLam}
%% Table \ref{tbl_lang1} gives the language that our machine will
%% execute, \machLam. A benefit of defining our own machine is that we
%% can also define the language it executes -- and the language we need
%% to compile to! We cannot make it too dissimilar from a ``real''
%% machine, but at this stage it helps to keep things simple. 

%% \begin{table}[th]
%%   \centering
%%   \begin{tabular}{lp{3.5in}}
%%     \emph{Instruction} & \emph{Description} \\
%%     \cmidrule(r){1-1}\cmidrule(r){2-2}
%%     \texttt{Store \emph{R} (\emph{F}, \emph{M})} & Store the value found in register #R# to field %%
%%     #F# of the value in register #M#. \\
%%     \texttt{Load (\emph{F}, \emph{M}) \emph{R}} & Load field #F# of the value in register #M# to register #R#. \\
%%     \texttt{Set \emph{v} \emph{R}} & Sets the register #R# to name of the variable $v$. \\
%%     \texttt{Copy \emph{R} \emph{M}} & Copies the contents of register #R# to register #M#. \\
%%     #Enter# & Jump to the location indicated by the closure in
%%     register #clo#, assuming an argument in register #arg#. The next #Return# executed
%%     will return to this location, with a result in register #res#.\\
%%     #Return# & Jump to the instruction following the most recently 
%%     executed #Enter# instruction and begin executing.  \\
%%     \texttt{MkClo \emph{L} [\emph{R}, \emph{S}, \dots]} &  Create a closure pointing to the 
%%     label #L# and holding the values in registers #R#, #S#, etc. The closure will be stored in 
%%     the #res# register.
%%   \end{tabular}
%%   \caption{\machLam, the ``machine language'' executed by our machine |M|.}
%%   \label{tbl_lang1}
%%   \figend
%% \end{table}

%% Each instruction supports an some aspect of the \lamA. In brief:
%% \begin{description}
%% \item[Variables] -- #Store# and #Load# help access variables and
%%   function arguments.
%% \item[Function Application] -- #Enter# and #Return# allow us to execute a function with arguments.
%% \item[Abstraction] -- #MkClo# lets us create functions as values.
%% \end{description}
%% The following sections describe each aspect in detail.

\subsection{Variables}
\label{subsec_lang1}

%% Free variables and environment
Consider how to find a value by its name. For example, consider
the |compose| function (expression \ref{eq_lang3}):
\begin{equation}
  \lamCompose.  \label{eq_lang1}
\end{equation}
We see three variables: $f$, $g$, and $x$. We say $x$ is \emph{bound},
because it is given as an argument, and that $f$ and $g$ are
\emph{free} because, in this context, they are not arguments in a 
$\lambda$-abstraction. To evaluate this expression, though, we need
a way to find the values of these terms.  

We can describe where to find $f, g$ and $x$ in terms of memory
locations. We can say that $x$ will appear in a special location,
|arg|, because it is the argument to the function and we will always
put arguments in the same place. We can further say that another
special location, |clo|, will have two
slots. The first will contain $g$ and the second will contain
$f$. Conceptually, then, our expression can be represented as:
\begin{center}
  \begin{tabular}{c}
    \begin{math}\begin{aligned}[b]
      |arg| &= x, \\
      |clo|[0] &= g, \\
      |clo|[1] &= f 
    \end{aligned}\text{\ in}\end{math} \\
    \lamAbs{|arg|}{\lamApp{|clo|[1]}{\lamPApp{|clo|[0]}{arg}}}.
  \end{tabular}
\end{center}

\par
In general, the $|clo|$ location holds the \emph{environment} for our
expression. For any given expression, we will be able to find all the
free variables (i.e., all those except the argument) in the
environment. The compiler will be responsible for ensuring the correct
environment is available whenever a given expression is evaluated.

%% Our machine, then, must have instructions for storing and retrieving
%% values. #Store# and #Load# (from Table \ref{tbl_lang1}) serve this
%% purpose. 

\subsection{Function Application}
\label{subsec_lang2}

%% Application & closures
Associating locations with names is not enough, however. Looking again
at expression \ref{eq_lang1}, $g$ clearly represents a function to
which we pass the argument $x$. To compute the value of
$\lamPApp{g}{x}$, we must be able to execute the code representing
$g$. We already assigned a storage location for $g$ ($|clo|[0]$) -- now
we just say that the value in $|clo|[0]$ is a \emph{label} that tells
us where to find the code representing $g$. However, $g$ will need
an environment of its own, to hold any free variables for $g$. Therefore,
we pair the label indicating where to find $g$ with a list of free
variables. We call this structure a \emph{closure}.

Closures are the fundamental data structures used to compile
functional languages. They may not have the exact form described here
but they always have the same purpose: they pair a label with the free
variables used in the function represented. 

\subsection{Abstraction}
\label{subsec_lang3}
The \lamA lets us define functions which return new functions. We have
seen how to access variables in the environment and how to execute
unknown functions using closures. Now we come to the final element
needed to compile the \lamA\ -- creating closures.

Consider the following expression, where we apply the $|const|$ function (expression 
\ref{eq_lang4}) to an argument:
\begin{equation}
  \begin{split}
    |main| &= \lamApp{|const|}{s} \\
         &= \lamAppP{\lamAbs{a}{\lamAbs{b}{a}}}{s}.
  \end{split}
\end{equation}
In order to evaluate $|main|$, we need to apply the $|const|$ function
to $s$. From the previous section we know that a closure is required to
implement function application. It follows that
\lamAbs{a}{\lamAbs{b}{a}} must create a closure which will
then be used to execute the body of the $\lambda$-abstraction with the
argument $s$. In fact, the ``value'' created by a
$\lambda$-abstraction is always a closure. The closure will point to
the body of the $\lambda$-abstraction and will hold the free variables
necessary to evaluate it.

%% \subsection{Compiling from \lamA to \machLam}

%% Table \ref{tbl_lang2} gives our algorithm to compile from \lamA to
%% \machLam. We present it in in three parts, \emph{a} - \emph{c},
%% corresponding to the syntax of \lamA terms given in Figure
%% \ref{lang_fig2}. The ``fat brackets,'' \compMach{t}, represent our
%% compiler, with the term being compiled given as the argument, $t$.
%% Each term compiles to a given sequence of instructions. We also assume
%% a function $\rho$, maintained by the compiler, that knows which
%% register holds a given variable.

%% %% Compilation rules ...
%% \afterpage{\clearpage{\input{machLamComp}}\clearpage}

%% Table \ref{tbl_lang2}, part \emph{a}, shows the compilation
%% scheme for variables. Variable refrences that are not used
%% in function application can only be the body of an expression, so we
%% just copy the variable's name to the #res#
%% register and return.

%% Function application, \lamPApp{f}{g}, is shown in part
%% \emph{b}. To apply a function, we must save the current #clo#
%% and #arg# registers. The compiler creates \emph{fresh} registers,
%% guaranteed to be unused anywhere else in the program, to store #clo#
%% and #arg#. We then use $\rho$ to find the registers holding $f$ and
%% $g$. Remember that $f$ will be a closure, while $g$ will be some
%% value. We copy those values into #clo# and #arg#. The #Enter#
%% instruction will execute the code pointed to by #clo#. When that
%% function returns, we restore #clo# and #arg# from the fresh registers
%% created earlier.

%% Abstractions, such as \lamAbs{x}{t}, return a closure pointing to the
%% code implementing $t$. Therefore, our compiler needs to generate code
%% that returns a closure, which in turn points to the code generated for
%% the body of the abstraction. To accomplish this, our compiler
%% recursively calls itself on the body. We get a label back, which is the
%% location of the just compiled code. In parts \emph{c} and \emph{d}
%% the expression $l = \compMach{\lamAbs{y}{t}}$ shows this
%% recursive call, and the label that results. That label can then be used in the 
%% closure returned by the abstraction.

%% We separate compilation of abstractions into two cases, depending if
%% the body is an abstraction or not. In the first case, as shown in part
%% \emph{c}, we begin by marking the location of this code with a new label,
%% #m#. We prepare to create a new closure by copying all values out of
%% the current closure into fresh registers. We then create a closure that
%% points to the body of our abstraction, contains all the values found
%% in the current closure, and ``captures'' our argument in the new
%% closure. 

%% For example, consider compiling this expression:

%% \begin{equation}
%%   \lamAbs{x}{\lamAbs{y}{\lamApp{f}{\lamPApp{y}{x}}}}. 
%% \end{equation}

%% $f$ and $x$ must be available when the body
%% \lamPApp{f}{\lamPApp{y}{x}} executes. Therefore, the closure returned
%% by \lamAbs{x}{(\dots)} must copy all values in the existing
%% closure as well as add the argument, $x$.

%% Part \emph{d} shows the code generated when the body of an abstraction
%% is \emph{not} another abstraction. We first mark the location of the
%% start of the body with a new label, #m#.  We then find the free
%% variables in the body, calling them $v_1, \dots, v_n$. This is a
%% compile-time operation, not something the program will do when
%% executing.  We assume that value of each free variables can be found
%% in the corresponding closure slot. For example, $v_0$ will be found in
%% $clo[0]$, $v_1$ in $clo[1]$, and so on. We also copy the $arg$
%% register to the corresponding register for our argument, as determined
%% by the $\rho$ function. Now that we have placed all variables in the
%% registers expected by our function, we generate the code for our body
%% and place it inline.

\section{Conclusion}
Functional languages distinguish themselves by their ability to treat
\emph{functions} as \emph{first-class values}. The \lamA, invented
some time before the first functional language, turned out to be a
simple but effective way to model (and experiment with) the behavior
of functional languages. Therefore, understanding how to compile the
\lamA can effectively show us how to compile functional languages in
general.

This chapter gave the basic mechanisms needed to understand the \lamA:
\emph{variables}, \emph{application}, and
\emph{abstraction}. Understanding how to compile the \lamA means
understanding how to compile these three mechanisms. Variables become
\emph{locations}. Application means evaluating a function with a given
\emph{environment} for any \emph{free variables}. Abstractions create
\emph{closures} that carry two pieces of information: the location of
the compiled function body and the value of free variables to be used
when evaluating the function.

\end{document}
