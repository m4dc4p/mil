\documentclass[12pt]{report}
%include polycode.fmt
%include lineno\lineno.fmt
\include{preamble}
\begin{document}
\input{document.preamble}

\chapter{The \LamA \& Functional Languages}
\label{ref_chapter_languages}

%% Overall: Justify why the lambda-calculus matters
%%   * Give syntax and evaluation rules for lambda-case
%%   * Set the foundation for MIL-to-LC later

John McCarthy created LISP, the first ``functional'' language, in 196X
\citep{McCarthyXX}. Here, ``functional'' refers to mathematical
functions, not the fact that it actually worked (though it did that
quite well too!). This class of languages revolve around defining,
manipulating and evaluating functions. A function that returns a
function can be hard to get used to, so some examples may help. First,
we look at some functions that just compute values -- they do not
return functions or anything fancy. 

\begin{myfig}[bth]
  \begin{tabular}{cc}
  \subfloat{%%
\begin{minipage}{1in}%%
> double :: Int -> Int {-"\label{lang_fig1_haskell_sig}"-}
> double a = 2 * a {-"\label{lang_fig1_haskell_impl}"-}
\end{minipage}%%
\label{lang_fig1_haskell}} & %%
  \subfloat{
%% \begin{minipage}[1in]
%%     \begin{lstlisting}[language=ml]%%
%% double : int -> int *!\label{lang_fig1_ml_sig}!*
%% double a = 2 * a *!\label{lang_fig1_ml_ref}*!
%%     \end{lstlisting}%%
%% \end{minipage}
\label{lang_fig1_ml}
  } \\
  \subref{lang_fig1_haskell} & \subref{lang_fig1_ml} \\
  \subfloat{%%
%% \begin{minipage}[1in]
%%     \begin{lstlisting}[language=scheme]%%
%% (def double a (* 2 a))
%%     \end{lstlisting}%%
%% \end{minipage}
\label{lang_fig1_scheme}
  } & \subfloat{%%
%% \begin{minipage}[1in]
%%     \begin{lstlisting}[language=javascript]%%
%% function double(a) { return 2 * a; }
%%     \end{lstlisting}%%
%% \end{minipage}
\label{lang_fig1_js}
  } \\
  \subref{lang_fig1_scheme} & \subref{lang_fig1_JS} 
  \end{tabular}
  \caption{Definitions of a function that doubles its argument in
    \subref{lang_fig1_haskell} Haskell, \subref{lang_fig1_ml} ML, 
    \subref{lang_fig1_scheme} Scheme, and \subref{lang_fig1_js} JavaScript.}
  \label{lang_fig1}
\end{myfig}

Figure~\ref{lang_fig1} shows a function that doubles an integer,
written in Haskell (Part \subref{lang_fig1_haskell}), ML (Part
\subref{lang_fig1_ml}), Scheme (Part \subref{lang_fig1_scheme}), and
JavaScript (Part \subref{lang_fig1_js}). Haskell and ML are
\emph{statically typed} languages, so their definitions begin with a
\emph{type signature}. Figure~\ref{lang_fig1}, Part
\ref{lang_fig1_haskell}, gives the Haskell
version. Line~\ref{lang_fig1_haskell_sig}, ``|double :: Int -> Int|,''
indicates that the function takes a value of type |Int| and returns an
|Int| (where |Int| represents an finite-precision integer value
\citep{HaskellReport}). Line~\ref{lang_fig1_haskell_impl} implements
|double|. The name comes first, followed by its argument
(``|a|''). The right-hand side of the equals sign gives the expression
that will be evaluated when the function is
applied. Part~\subref{lang_fig1_ml_impl} gives the ML
implementation. Line~\ref{lang_fig1_ml_impl} gives the type signature
for \lstinline[language=ml]=double=, ``\lstinline[language=ml]=double
:: int -> int=,' ' with much the same meaning as the Haskell
version. The following line gives the implementation of
\lstinline[language=ml]=double=, again following the Haskell
pattern. Part \subref{lang_fig1_scheme} gives the Scheme
defintion. Scheme is a dynamically typed language, so no signatures
can be given -- just the implementation. The function is introduced by
the ``\lstinline[language=scheme]=def='' keyword, followed by the
function name and any arguments (``\lstinline[language=scheme]=double
a='').  The postfix expression, ``\lstinline[language=scheme]=(* 2
a)=,'' indicates the argument is doubled when the function is
applied. Part \subref{lang_fig1_js} shows the JavaScript
version. JavaScript is also a dynamically typed language, so no type
signature can be given. All functions are introduced by the
``\lstinline[language=javascript]=function='' keyword, followed by the
function name and any arguments. The body of the function, on
Line~\ref{fig_lang1_js_impl}, uses the
``\lstinline[language=javascript]=return='' keyword to indicate the
function doubles its argument and returns the resulting value.

...

\section{Why \LamA?}
\ref{lang_sec1_}

The \lamA really is the essential functional programming language.  
That does not mean it is the programming language anyone
should ever use outside research or theoretical settings. What it
means is the \lamA has everything you need to model the behavior
of other programming languages. 

Of course, you could say the same about any Turing-complete
language. What makes the \lamA special is its simplicity. Nothing is
built-in, not even the natural numbers. There is almost nothing to get
in the way of studying your particular domain, rather than fiddling
with the programming language.

Again, that could be said about any sufficiently simple
Turing-complete programming language. However, the \lamA is inherently
functional -- it can only define functions, and all values computed
are themselves functional. Translating from the \lamA to
another functional language is usually straightforward (or maybe your
target language isn't very functional). 

Its power, simplicity, and functional nature make the \lamA so popular
in functional language research, and motivate our own choice in using
it. We do not show how to compile a ``real-world'' functional language
to our intermediate language, but by showing how to compile the 
\lamA to our language, we show our technique could be used by ``real'' 
functional languages (with some adaptions, of course).

%% We will be demonstrating a number of dataflow optimizations over
%% our intermediate language programs, but all of our source programs will
%% be written in a variant of the \lamA. Any variante

%% A compilation technique demonstrated for
%% some variant of the \lamA can be translated into any other functional
%% programming language. Making the translation work well with the syntax
%% and semantics of the target language is still hard work, but
%% absolutely possible -- a result developed for the \lamA really is
%% universal (as far as you want to make use of that result, of course). 

%% It is these three reasons that make the \lamA such a popular
%% language for showing theoretic (or practical) results

%% This chapter introduces the \lamA calcus, giving its 

%% Most importantly, results obtained
%% using the \lamA are guaranteed to translate to other Turing-complete
%% languages -- and usually with better syntax! 

%% Being Turing-complete, the \lamA is capable of exeucting any program
%% you could write on a modern computer.  

%%  . What it does mean is that anything possible in the \lamA Being
%% Turing-complete, it can be

%% \emph{\ldots transition
%%   \ldots}. Most importantly, the \lamA serves as the \emph{lingua
%%   franca} for functional programmers. It provides a way to translate
%% between functional programming languages, and a way to carry
%% developments from one language to another. 

%% so its capabilities are
%% as powerful as any other Turing-complete programming language. 

%% Being Turing-complete, it can emulate any other
%% Turing-complete language. Its direct support for manipulating
%% functions-as-values makes it a good choice for emulating higher-level
%% functional languages.

%% It is not a language that you want to write many 
%% programs in, 

%% Its sparse syntax
%% and straightforward evaluation rules means their is less to worry about
%% when trying out new design ideas or theories.  . Most importantly, though, 


%% Figure~\ref{lang_fig1} defines
%% a function for adding two numbers in Scheme, ML, Haskell and JavaScript,
%% some of the more prominent functional languages in use today. 




 
%% 1. Relate lambda-calculus to functional langauges in general
%% 2. Define the lambda-calculus
%%    * syntax, semantics, evaluation rules
%% 3. Compliling - or better to move that to MIL chapter?

Informally, a \emph{function} is a mathematical definition that takes
arguments and computes some result. For example, \emph{plus1} just adds 1 
to its argument, using the normal rules of arithmetic:
\begin{equation}
  |plus1|\ x = x + 1.
\end{equation}
We are not limited to defining functions that add 1. Functions can
also be \emph{values} -- just as 1 or $x$ are in the expression
above. Here, we define a function, that returns a function, that always
adds 1:
\begin{equation}
  |adder1| = \lambda\ x = x + 1.
\end{equation}
In |adder1|, ``$\lambda\ x$'' indicates we return a function that takes one
argument. We can go further and define a function that, given an
argument, returns a function which always adds that amount:
\begin{equation}
  |adder|\ n = \lambda\ x = x + n.
\end{equation}
Notice how the outer argument $n$ gets ``captured'' by the body $x +
n$. Using $|adder|$, we can now re-define $|adder1|$ above:
\begin{equation}
  |adder1| = |adder|\ 1.
\end{equation}

Other functional languages created since then include 
Scheme, ML, Haskell, and many more. While syntax, semantics and capabilities
differ widely between all these languages, they all share the characteristic
shown above: \emph{the ability to manipulate functions as first-class values}.

\section{The \LamA}
%%\emph{Why is it important}

%%\emph{What is the \lamA}

Alonzo Church defined his \lamA (``lambda calculus'') in 19XX
\citep{ChurchXX} to study systems of recursive equations. Being
Turing-complete, it can be used to model the behavior of any
computational system. However, it is particularly useful for modeling
functional programming languages. %% why?

Figure \ref{fig_lang1} gives a syntax for the ``pure''
\lamA. ``Abstraction'' defines a new function, while ``application''
gives a particular argument to a function. ``Variables'' are defined
when mentioned. 

\begin{myfig}[ht]
\begin{minipage}{3in}
\begin{Verbatim}
##                 ##      ##       
 #                  #       #       
 #  ###  ########   ###   ###  ###  
 #  ###   #  #  #   #  # #  #  ###  
 #  # #   #  #  #   #  # #  #  # #  
### ## # #########  ###   #### ## # 
\end{Verbatim}
\end{minipage}
  \caption{The \lamA' syntax.}
  \label{fig_lang1}
\end{myfig}

%%\emph{What does it look like?}

Using this syntax, we can define some common functions. |Identity|
returns its argument:
\begin{align}
  |identity| &= \lamAbs{x}{x}. \label{eq_lang2} \\
  \intertext{|Const| takes two arguments but always returns the first:}
  |const| &= \lamAbs{a}{\lamAbs{b}{a}}. \label{eq_lang4} \\
  \intertext{|Compose| takes two functions and an argument. The result of
    applying the second function to the argument is passed to the first:}
  |compose| &= \lamCompose. \label{eq_lang3} 
\end{align}
Note that function application is right-associative, meaning
\lamPApp{f}{\lamPApp{g}{x}} is the same as \lamApp{\lamApp{f}{g}}{x},
but \emph{not} the same as \lamPApp{\lamPApp{f}{g}}{x}.

\begin{myfig}[bt]
\begin{minipage}{2in}
\begin{Verbatim}
                ##  
                 #  
 ##  ## ## ###   #  
####  # ## ###   #  
#     ###  # #   #  
 ###   #   ## # ### 
\end{Verbatim}
\end{minipage}
  \caption{Evaluation rules for \lamA. These rules show 
    \emph{call-by-value}, where arguments are evaluated
    before functions.}
  \label{fig_lang2}
\end{myfig}

A \lamA term executes by rewriting the expression according to the
rules in Figure \ref{fig_lang2}. We match our term to each of the
patterns above the line. If we have a match, we rewrite according to
the pattern below the line. When no more matches can be made, we say
the term is in \emph{normal form}: we have finished executing.

The rules given implement \emph{call-by-value} evaluation order,
meaning arguments to a function are evaluated before the function
itself. Other variants include \emph{call-by-need} and
\emph{call-by-name}, where arguments are not evaluated until
needed. We do not considers those variants further, however.

\section{Compiling the \LamA}
\label{sec_lang1}

%% Define which steps in compilation we're going to worry about
Compiling even a language as simple as the \lamA involves a number of
steps, such as defining a concrete syntax, parsing source programs
into an abstract syntax tree (AST), and producing an executable
program from the AST. For our purposes, however, we just focus on the
\lamA' three fundamental operations:

\begin{itemize}
\item Naming values (\emph{variables}).
\item Apply a function to an argument (\emph{application}).
\item Create a new function (\emph{abstraction}). 
\end{itemize}

Any compiler for the \lamA must be able to produce executable programs
which implement these operations. 

%% \subsection{The Target Machine}
%% We begin by defining a \emph{target machine}, |M|, for our compiler. To
%% reduce complexity we do not target an actual computer, but one of our
%% own design. Our machine will have an infinite number of
%% \emph{registers} (i.e., storage locations) that we can refer to by
%% name. It will have an unlimited supply of memory (called the
%% \emph{heap}) in which we can allocate structured values. However, we
%% will not refer to memory locations directly. Instead, we will always
%% store references to heap values in registers. Finally, the machine
%% will execute a list of instructions (our \emph{program}), starting at
%% the beginning and proceeding in sequential order (unless otherwise
%% instructed), until reaching the end of the list. Each instruction will
%% have a definite location, but we will only refer to certain special
%% locations using named labels.

%% \subsection{M's Language: \machLam}
%% Table \ref{tbl_lang1} gives the language that our machine will
%% execute, \machLam. A benefit of defining our own machine is that we
%% can also define the language it executes -- and the language we need
%% to compile to! We cannot make it too dissimilar from a ``real''
%% machine, but at this stage it helps to keep things simple. 

%% \begin{table}[th]
%%   \centering
%%   \begin{tabular}{lp{3.5in}}
%%     \emph{Instruction} & \emph{Description} \\
%%     \cmidrule(r){1-1}\cmidrule(r){2-2}
%%     \texttt{Store \emph{R} (\emph{F}, \emph{M})} & Store the value found in register #R# to field %%
%%     #F# of the value in register #M#. \\
%%     \texttt{Load (\emph{F}, \emph{M}) \emph{R}} & Load field #F# of the value in register #M# to register #R#. \\
%%     \texttt{Set \emph{v} \emph{R}} & Sets the register #R# to name of the variable $v$. \\
%%     \texttt{Copy \emph{R} \emph{M}} & Copies the contents of register #R# to register #M#. \\
%%     #Enter# & Jump to the location indicated by the closure in
%%     register #clo#, assuming an argument in register #arg#. The next #Return# executed
%%     will return to this location, with a result in register #res#.\\
%%     #Return# & Jump to the instruction following the most recently 
%%     executed #Enter# instruction and begin executing.  \\
%%     \texttt{MkClo \emph{L} [\emph{R}, \emph{S}, \dots]} &  Create a closure pointing to the 
%%     label #L# and holding the values in registers #R#, #S#, etc. The closure will be stored in 
%%     the #res# register.
%%   \end{tabular}
%%   \caption{\machLam, the ``machine language'' executed by our machine |M|.}
%%   \label{tbl_lang1}
%%   \figend
%% \end{table}

%% Each instruction supports an some aspect of the \lamA. In brief:
%% \begin{description}
%% \item[Variables] -- #Store# and #Load# help access variables and
%%   function arguments.
%% \item[Function Application] -- #Enter# and #Return# allow us to execute a function with arguments.
%% \item[Abstraction] -- #MkClo# lets us create functions as values.
%% \end{description}
%% The following sections describe each aspect in detail.

\subsection{Variables}
\label{subsec_lang1}

%% Free variables and environment
Consider how to find a value by its name. For example, consider
the |compose| function (expression \ref{eq_lang3}):
\begin{equation}
  \lamCompose.  \label{eq_lang1}
\end{equation}
We see three variables: $f$, $g$, and $x$. We say $x$ is \emph{bound},
because it is given as an argument, and that $f$ and $g$ are
\emph{free} because, in this context, they are not arguments in a 
$\lambda$-abstraction. To evaluate this expression, though, we need
a way to find the values of these terms.  

We can describe where to find $f, g$ and $x$ in terms of memory
locations. We can say that $x$ will appear in a special location,
|arg|, because it is the argument to the function and we will always
put arguments in the same place. We can further say that another
special location, |clo|, will have two
slots. The first will contain $g$ and the second will contain
$f$. Conceptually, then, our expression can be represented as:
\begin{center}
  \begin{tabular}{c}
    \begin{math}\begin{aligned}[b]
      |arg| &= x, \\
      |clo|[0] &= g, \\
      |clo|[1] &= f 
    \end{aligned}\text{\ in}\end{math} \\
    \lamAbs{|arg|}{\lamApp{|clo|[1]}{\lamPApp{|clo|[0]}{arg}}}.
  \end{tabular}
\end{center}

\par
In general, the $|clo|$ location holds the \emph{environment} for our
expression. For any given expression, we will be able to find all the
free variables (i.e., all those except the argument) in the
environment. The compiler will be responsible for ensuring the correct
environment is available whenever a given expression is evaluated.

%% Our machine, then, must have instructions for storing and retrieving
%% values. #Store# and #Load# (from Table \ref{tbl_lang1}) serve this
%% purpose. 

\subsection{Function Application}
\label{subsec_lang2}

%% Application & closures
Associating locations with names is not enough, however. Looking again
at expression \ref{eq_lang1}, $g$ clearly represents a function to
which we pass the argument $x$. To compute the value of
$\lamPApp{g}{x}$, we must be able to execute the code representing
$g$. We already assigned a storage location for $g$ ($|clo|[0]$) -- now
we just say that the value in $|clo|[0]$ is a \emph{label} that tells
us where to find the code representing $g$. However, $g$ will need
an environment of its own, to hold any free variables for $g$. Therefore,
we pair the label indicating where to find $g$ with a list of free
variables. We call this structure a \emph{closure}.

Closures are the fundamental data structures used to compile
functional languages. They may not have the exact form described here
but they always have the same purpose: they pair a label with the free
variables used in the function represented. 

\subsection{Abstraction}
\label{subsec_lang3}
The \lamA lets us define functions which return new functions. We have
seen how to access variables in the environment and how to execute
unknown functions using closures. Now we come to the final element
needed to compile the \lamA\ -- creating closures.

Consider the following expression, where we apply the $|const|$ function (expression 
\ref{eq_lang4}) to an argument:
\begin{equation}
  \begin{split}
    |main| &= \lamApp{|const|}{s} \\
         &= \lamAppP{\lamAbs{a}{\lamAbs{b}{a}}}{s}.
  \end{split}
\end{equation}
In order to evaluate $|main|$, we need to apply the $|const|$ function
to $s$. From the previous section we know that a closure is required to
implement function application. It follows that
\lamAbs{a}{\lamAbs{b}{a}} must create a closure which will
then be used to execute the body of the $\lambda$-abstraction with the
argument $s$. In fact, the ``value'' created by a
$\lambda$-abstraction is always a closure. The closure will point to
the body of the $\lambda$-abstraction and will hold the free variables
necessary to evaluate it.

%% \subsection{Compiling from \lamA to \machLam}

%% Table \ref{tbl_lang2} gives our algorithm to compile from \lamA to
%% \machLam. We present it in in three parts, \emph{a} - \emph{c},
%% corresponding to the syntax of \lamA terms given in Figure
%% \ref{fig_lang1}. The ``fat brackets,'' \compMach{t}, represent our
%% compiler, with the term being compiled given as the argument, $t$.
%% Each term compiles to a given sequence of instructions. We also assume
%% a function $\rho$, maintained by the compiler, that knows which
%% register holds a given variable.

%% %% Compilation rules ...
%% \afterpage{\clearpage{\input{machLamComp}}\clearpage}

%% Table \ref{tbl_lang2}, part \emph{a}, shows the compilation
%% scheme for variables. Variable refrences that are not used
%% in function application can only be the body of an expression, so we
%% just copy the variable's name to the #res#
%% register and return.

%% Function application, \lamPApp{f}{g}, is shown in part
%% \emph{b}. To apply a function, we must save the current #clo#
%% and #arg# registers. The compiler creates \emph{fresh} registers,
%% guaranteed to be unused anywhere else in the program, to store #clo#
%% and #arg#. We then use $\rho$ to find the registers holding $f$ and
%% $g$. Remember that $f$ will be a closure, while $g$ will be some
%% value. We copy those values into #clo# and #arg#. The #Enter#
%% instruction will execute the code pointed to by #clo#. When that
%% function returns, we restore #clo# and #arg# from the fresh registers
%% created earlier.

%% Abstractions, such as \lamAbs{x}{t}, return a closure pointing to the
%% code implementing $t$. Therefore, our compiler needs to generate code
%% that returns a closure, which in turn points to the code generated for
%% the body of the abstraction. To accomplish this, our compiler
%% recursively calls itself on the body. We get a label back, which is the
%% location of the just compiled code. In parts \emph{c} and \emph{d}
%% the expression $l = \compMach{\lamAbs{y}{t}}$ shows this
%% recursive call, and the label that results. That label can then be used in the 
%% closure returned by the abstraction.

%% We separate compilation of abstractions into two cases, depending if
%% the body is an abstraction or not. In the first case, as shown in part
%% \emph{c}, we begin by marking the location of this code with a new label,
%% #m#. We prepare to create a new closure by copying all values out of
%% the current closure into fresh registers. We then create a closure that
%% points to the body of our abstraction, contains all the values found
%% in the current closure, and ``captures'' our argument in the new
%% closure. 

%% For example, consider compiling this expression:

%% \begin{equation}
%%   \lamAbs{x}{\lamAbs{y}{\lamApp{f}{\lamPApp{y}{x}}}}. 
%% \end{equation}

%% $f$ and $x$ must be available when the body
%% \lamPApp{f}{\lamPApp{y}{x}} executes. Therefore, the closure returned
%% by \lamAbs{x}{(\dots)} must copy all values in the existing
%% closure as well as add the argument, $x$.

%% Part \emph{d} shows the code generated when the body of an abstraction
%% is \emph{not} another abstraction. We first mark the location of the
%% start of the body with a new label, #m#.  We then find the free
%% variables in the body, calling them $v_1, \dots, v_n$. This is a
%% compile-time operation, not something the program will do when
%% executing.  We assume that value of each free variables can be found
%% in the corresponding closure slot. For example, $v_0$ will be found in
%% $clo[0]$, $v_1$ in $clo[1]$, and so on. We also copy the $arg$
%% register to the corresponding register for our argument, as determined
%% by the $\rho$ function. Now that we have placed all variables in the
%% registers expected by our function, we generate the code for our body
%% and place it inline.

\section{Conclusion}
Functional languages distinguish themselves by their ability to treat
\emph{functions} as \emph{first-class values}. The \lamA, invented
some time before the first functional language, turned out to be a
simple but effective way to model (and experiment with) the behavior
of functional languages. Therefore, understanding how to compile the
\lamA can effectively show us how to compile functional languages in
general.

This chapter gave the basic mechanisms needed to understand the \lamA:
\emph{variables}, \emph{application}, and
\emph{abstraction}. Understanding how to compile the \lamA means
understanding how to compile these three mechanisms. Variables become
\emph{locations}. Application means evaluating a function with a given
\emph{environment} for any \emph{free variables}. Abstractions create
\emph{closures} that carry two pieces of information: the location of
the compiled function body and the value of free variables to be used
when evaluating the function.

\end{document}
