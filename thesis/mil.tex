\documentclass[12pt]{report}
%include polycode.fmt
\input{preamble}
\begin{document}
\input{document.preamble}

\chapter{A Monadic Intermediate Language}
\label{ref_chapter_mil}

%% What is an intermediate language? What is a ``Monadic'' one?
Most compilers do not generate executable machine code directly from a
program source file. Rather, programs get translated into one or more
\emph{intermediate forms}. The compiler may implement a pipeline of
translations, each translating the program into a more detailed (i.e.,
lower-level) representation. Frequently these intermediate forms are 
also languages, with their own syntax, semantics, type-systems,
and more. 

\section{Three-address Code}

Intermediate forms typically expose more detail about the
implementation of a program, while at the same time making some
optimization or transformation easier or even possible. 
\emph{Three-address code}, one such intermediate form, translates the
program into assembly-language like form, using registers to
hold values. Infinitely many registers can be named, making registers
more like memory locations than registers in real hardware. Each
instruction in the translated program has two operand registers and one
destination register, thus the name ``three-address.'' 

Three-address code makes all intermediate expression values explicit, 
by reducing complicated expressions to a series of assignments. 
For example, the expression:
\begin{equation}
  a = \frac{(b * c + d)}{2},
\end{equation}
would be expressed in three-address code as:
\begin{AVerb}
  s = b * c;
  t = s + d;
  a = t / 2;
\end{AVerb}
where #s# and #t# are new temporaries created by the compiler. This 
representation makes it easier for the compiler to re-order expressions,
unravel complex control-flow, and manipulate intermediate values. 

\section{Monadic Intermediate Language}

Our intermediate language, MIL, serves the same purpose as
three-address code and other intermediate forms: it exposes more
detail about the implementation of a program, while making some
optimizations simpler or even possible. In contrast to three-address
code, however, our language supports features unique to functional
languages: the ability to treat functions as first-class values, and
the representation of stateful computations in a monad.

\subsection{Monads \& Functional Programming}
As described by Wadler \citep{Wadler1990}, \emph{monads} can be used
distinguish \emph{pure} and \emph{impure} functions. A \emph{pure}
function has no side-effects: it will not print to the screen, throw
an exception, write to disk, or in any other way change the obversable
state of the machine. An \emph{impure} function may change the
machine's state.

%% Presentation drawn from http://en.wikipedia.org/wiki/Monad_%28functional_programming%29, 
%% accessed April 6 2010.
A \emph{monad} provides the abstraction that separates pure and impure
functions. Impure (or ``monadic'') functions execute ``inside'' the
monad. Values returned from a monadic function are not directly
accessible -- they are ``wrapped'' in the monad. The only way
to ``unwrap'' a monadic value is to execute the computation -- inside
the monad! 

\subsection{The Monad in MIL}

When designing MIL we wished to make all memory allocation
explicit. Besides the obvious effect of reducing free memory
available, allocation can also cause two other effects: the allocation
may fail, or a garbage-collection may occur. A monad allows us to
separate computations which (potentially) allocate memory from those
that do not.

\subsection{MIL Example: $compose$}

To give a sense of MIL, consider the definition of $compose$ given in
Figure~\ref{fig_mil1a}. Figure~\ref{fig_mil1b} shows a fragment of this 
expression in MIL. The \emph{block declaration}
on Line~\ref{fig_mil1b_block_decl} gives the name of
the block (#compose#) and arguments that will be passed in (#f#, #g#,
and #x#). Line~\ref{fig_mil1b_gofx} applies #g# to #x# and assigns
the result to #t1#. The ``enter'' operator (#@@#), represents function application.
\footnote{So called because in the expression #g @@ x#, we ``enter''
  function #g# with the argument #x#.}  We assume #g# refers to a
function (or, more precisely, a \emph{closure}). The ``bind'' operator
(#<-#) assigns the result of the operation on its right-hand side to
the location on the left. In turn, Line~\ref{fig_mil1b_fofx} applies
#f# to #t1# and assigns the result to #t2#. The last line returns
#t2#. Thus, the #compose# block returns the value of
\lamApPp{f}{\lamApp{g}{x}}, just as in our original \lamA expression.

\begin{myfig}[t]
  \begin{tabular}{cc}
    \subfloat{$compose = \lamCompose$%%
      \label{fig_mil1a}} & 
    \subfloat{\input{lst_mil1}\label{fig_mil1b}} \\
    \subref{fig_mil1a} & \subref{fig_mil1b}
  \end{tabular} 
  \caption{\subref{fig_mil1a} gives a \lamA definition of the composition
    function; \subref{fig_mil1b} shows a fragment of the MIL program
    for $compose$.}
  \label{fig_mil1}
\end{myfig}

%% Closures

However, according to rules in Figure~\ref{lang_fig6},
Chapter~\ref{ref_chapter_languages} on page~\pageref{lang_fig6},
evaluating an expression which applies $compose$ actually involves the
creation of several intermediate values. Consider the expression
\begin{equation}
  main = \lamApp{\lamApp{\lamApp{compose}{a}}{b}}{c}, \label{eqn_mil4}
\end{equation}
where $a$, $b$ and $c$ are given values elsewhere. Using the
rules for call-by-value evaluation order from Figure~\ref{lang_fig6} in 
Chapter \ref{ref_chapter_languages}, we can compute the value of the expression
as follows:
\begin{align*}
  main &= \lamApp{\lamApp{\lamApp{compose}{a}}{b}}{c} \\
  &= \lamApp{\lamApp{\lamAPp{\lamCompose}{a}}{b}}{c} & \text{\emph{Definition of |compose|.}} \\
  &= \lamApp{\lamAPp{\lamAbs{g}{\lamAbs{x}{\lamApP{a}{\lamApp{g}{x}}}}}{b}}{c} & \text{\emph{E-App.}} \\
  &= \lamAPp{\lamAbs{x}{\lamApP{a}{\lamApp{b}{x}}}}{c} & \text{\emph{E-App.}} \\
  &= \lamApP{a}{\lamApp{b}{c}}. & \text{\emph{E-App.}} 
\end{align*}

We can capture each intermediate value created when evaluating this
expression by assigning each result to a new variable. 

\begin{align*}
  main &= \lamApp{\lamApp{\lamApp{compose}{a}}{b}}{c} \\
  &= \lamApp{\lamApp{\lamAPp{\lamCompose}{a}}{b}}{c} & \text{\emph{Definition of |compose|.}} \\
  t_1 &\leftarrow \lamAbs{g}{\lamAbs{x}{\lamApP{a}{\lamApp{g}{x}}}} & \text{\emph{Result of E-App.}}\\
  &= \lamApp{t_1}{\lamApp{b}{c}} \\
  t_2 &\leftarrow \lamAbs{x}{\lamApP{a}{\lamApp{b}{x}}} & \text{\emph{Result of E-App.}} \\
  &= \lamApp{t_2}{c} \\
  t_3 &\leftarrow \lamApP{a}{\lamApp{b}{c}} & \text{\emph{Result of E-App.}} \\
  &= t_3.
\end{align*}

We apply $t_1$ to $b$ to create our next intermediate value, $t_2$:
\begin{equation}
  t_2 = \lamApp{t_1}{b} = \lamAbs{x}{\lamApp{a}{\lamApp{b}{x}}}. \label{eqn_mil2}
\end{equation}
Finally, we compute our final value, $main$, by applying $t_2$ to $c$:
\begin{equation}
  main = \lamApp{t_2}{c} = \lamApp{a}{\lamApp{b}{c}}. \label{eqn_mil3}  
\end{equation}

Both $t_1$ and $t_2$ will hold \emph{closures} when evaluating
expression \eqref{eqn_mil4}. As detailed in Section \ref{subsec_lang2}, a closure
holds a pointer to a body of code and any \emph{free variables}. In this case,
$t_1$ holds $a$ and points to the code that evaulates to $t_2$. In turn, $t_2$
holds $a$ and $b$, and points to the code which evaluates to $main$. The
\lamA does not make this explicit, but our MIL does. 

\begin{myfig}[t]
  \input{lst_mil2}
  \caption{The MIL program which computes $main = \lamApp{\lamApp{\lamApp{compose}{a}}{b}}{c}$. Note that $a$, $b$, and $c$ are assumed to be arguments given
    outside the program.}
  \label{fig_mil2}
\end{myfig}

Figure \ref{fig_mil2} shows the complete MIL program for $main =
\lamApp{\lamApp{\lamApp{compose}{a}}{b}}{c}$. #k1#, #k2# and #k3#
(lines \ref{fig_mil2_k1} -- \ref{fig_mil2_k3}) represent
\emph{closure-capturing} blocks. As opposed to #main#, these blocks
create new closures. In the definition #k1 {} f = k2 {f}#, the braces
on the left-hand side represent variables expected in the closure
given to this function. In this case, #k1# does not expect to find any
variables. #f# names the argument given to #k1#. The right-hand side,
#k2 {f}#, shows the creation of a new closure. The closure points to
#k2# and captures the value of #f#. In other words, evaluating #k1#
returns a closure which can be used to execute #k2#. #k2# behaves
similarly. It expects to find one value in its closure (#{f}#) and
returns a closure pointing to #k3# that copies the value #f# from the
existing closure and adds the argument, #g# (#k3 {f,g}#). #k3#,
however, does something new. Instead of returning a closure, it
executes the #compose# block (defined in Figure \ref{fig_mil1b}) with
three arguments: #f#, #g#, and #x#. This does \emph{not} return a
closure or ``enter'' a function. Instead, we jump directly to the
block. The value returned by #k3# will be the value computed by
#compose# with the arguments given.

Returning to #main# on line \ref{fig_mil2_main} in Figure
\ref{fig_mil2}, we can now see how MIL makes explicit the intemediate
closures created while evaluating
\lamApp{\lamApp{\lamApp{compose}{a}}{b}}{c}. On line
\ref{fig_mil2_t1}, we enter #k1# with the first argument, #a#. #t1#
holds the closure returned. On the next line, we enter #t1# (which
will point to #k2#) with the second argument, #b#. #t2# then holds the
closure returned. Finally, on line \ref{fig_mil2_t3}, we enter #t2#
(which will point to #k3#) with the final argument, #c#. #k3# will directly
execute #compose# with our specific arguments. #t3# holds the result returned
by #compose#. On the last line of #main# we return the value computed, #t3#.

%% Syntax of MIL
\subsection{MIL Syntax}

Figure \ref{fig_mil3} gives the syntax for MIL.  A MIL program
consists of a number of \emph{blocks}: \emph{closure} blocks (line
\ref{fig_mil3_k1}), basic blocks (line \ref{fig_mil3_b}) and top-level
blocks (line \ref{fig_mil3_t}). Though the syntax for closure blocks
seems to allow any tail, in practice they can only do one of two
things: either return a closure (\texttt{k \{\dots\}}) or jump to a
basic block (\texttt{b(\dots)}). Top-level blocks (line
\ref{fig_mil3_t}) provide an entry point for top-level functions --
they provide a closure which can be used to initially ``enter'' the
function.

\afterpage{\clearpage{\input{mil_syntax}}\clearpage}

Basic blocks (line \ref{fig_mil3_body}) consist of a sequence of statements that
execute in order without any intra-block jumps or conditional
branches. Each basic block ends with a branch: either they return a
value (#done#) or take conditional branch (#case#). Conditional
branches can specify multiple destinations, though at any given time
only one will be taken.

The #case# statement (line \ref{fig_mil3_case}) specifies a list of
\emph{alternatives}, each of which matches a \emph{constructor} and
binds new variables to the values held by the constructor. #case#
examines the variable given (note, this cannot be an expression) and
selects the alternative that matches the constructor
found. Alternatives always branch immediately to some block -- they do
not allow any other statement. The result of block called becomes the
result of the #case#, which in turn becomese the result of the calling
block.

Only the binding statement (line \ref{fig_mil3_bind}) can appear multiple
times in a block. Each binding assigns the result of the \emph{tail}
on the right-hand side to a variable on the left. If a variable is
bound more than once, later bindings will ``shadow'' previous
bindings.

The #done# statement (line \ref{fig_mil3_done}) ends a block and returns
the value of tail expression specified.

\emph{Tail} expressions represent effects -- they create monadic
values. #return# (line \ref{fig_mil3_return}) takes a variable and
makes its value monadic. Notice it can only take a variable, not an
expression.  The ``enter'' operator, #@@#, expects a closure on its
left and some value on the right. It will enter the function pointed
to by the closure, with the argument given, and will evaluate to the
result of that function. #k#, the ``capture'' operator, creates a
closure from a block name and a list of variables. The name given is
not an arbitrary code pointer -- it is a location determined during
compilation. The ``goto'' expression, \texttt{b(\dots)}, jumps to the
particular block with the arguments given. Again, this is not a
computed value -- #b# represents a known location for the block. The
variables mentioned in the #goto# do not have to have the same names
as those given in the block's declaration. The constructor expression,
``C'', will create a data value with the given tag (``C'') and
variables. Primitives, which are not implemented in MIL, have the form
#p*# and are treated the same as ``goto'' expressions. They are not 
implemented in MIL, however. 

\section{Compiling \lamA to MIL}

\emph{\dots Lots of text \dots}

\section{Intermediate Languages, MIL, and Three-Address Code}

Intermediate langauges, and three-address code in particular, have at
least two purposes: making certain optimizations simpler, and exposing
more details about implementation. The intermediate language does
\emph{not} expose all details about implementation -- only those the
designers considered relevant. Three-address code accomplishes this
first goal by reducing the complexity of expresssions that need to be
analyzed. The second goal is achieved by deferring decisions about the
actual location of values to some later stage of compilation.
Finally, while not required, three-address code also easily adapts to
organizing code into basic blocks, which makes control-flow analysis
much simpler.

Our MIL shares some of the same goals as three-address code, and
accomplishes them in similar ways. Blocks do not have complex
structure -- they either return a closure, jump to another block, or
execute a series of statements followed by a return or branch. Tail
expressions ensure that all intermediate values are named, and also 
isolate monadic effects to one area of the language. Finally, the limited
number of statements ensure control-flow is straightforward.

\section{Conclusion}

This chapter presented our Monadic Intermediate Language (MIL). Our
MIL resembles three-address code in sevarl ways: infinitely many
registers can be named, nested expressions are not allowed, and
implementatino details are made explicit. The MIL's unique features
include separate representations for \emph{closure-capturing} and
basic blocks, and the use of monadic \emph{tail} expressions. We 
presented a simple scheme for compiling the \lamA given in
Chapter \ref{ref_chapter_languages} to our MIL. Later will be devoted
to optimizing those MIL programs using dataflow techniques.

%% Compiling the lambda-calculus to MIL

%% \section{Monadic Intermediate Language}

%% %% What does the language support?

%% Our monadic language takes its inspiration from Haskell's @do@
%% notation. It is a pure functional language, making allocation of data
%% structures and closures explicit via monadic syntax. Functions in MIL
%% define computations which, when run, can affect heap memory. Figure
%% \ref{figMILDef} gives the syntax of the language.

%% %% TODO: Mention that v restricts the term to variables
%% %% only.

%% MIL programs consist of a series of definitions (@defM@). Each
%% definition can be any of the following.

%% \begin{description}
%%   \item[Closure-capturing] (@k {v1, ..., vN} v = k1 {v1, ..., vN, v}@) -- This function
%%     expects to find the variables @v1, ..., vN@ in its own closure. It constructs
%%     a new closure containing the existing variables plus the newly captured variable
%%     @v@. The new closure refers to @k1@, another closure-capturing function.
%%   \item[Block-calling] (@k {v1, ..., vN} v = b(v1, ..., vN, v)@) -- This function immediately
%%     jumps to block @b@ with arguments @v1, ..., vN@ and @v@. No closure value needs to
%%     be constructed. 
%%   \item[Function block] (@b(v1, ..., vN) = bodyM@) -- This function executes the statements
%%     in the body. 
%%   \item[Top-level] (@t <- k {}@) -- This special case ensures top-level definitions in the program
%%     can be accessed like any other function. The notation indicates that @t@ holds a closure
%%     structure, referring to the definition @k@. 
%% \end{description}

%% Notice that we can distinguish syntatically between functions that
%% merely create a closure (@k { ... }@) and those that do actual work
%% (@b(...)@). The body of a @k@ functin can only allocate another
%% closure or jump to a block. A block, on the other hand, can do other
%% work, but it cannot directly return a closure. As will be described in
%% chapter \ref{ref_chapter_uncurrying} this makes it much easier to
%% recognize and elminate intermediate closures.

%% The body of each block consists of statements followed by a
%% \emph{tail}. Tails can only
%% appear as the last statement in a block or on the right-hand side of
%% the monadic arrow (``@<-@''). Tail instructions, in other words, cause 
%% effects. The three tail statements follow:

%% \begin{description}
%% \item[Return a computation] (@return v@) -- Returns the result of a computation
%%   to the caller.

%% \item[Create a closure] (@k {v1, ..., vN}@) -- Creates a closure pointing to
%%   function @k@, capturing variables @v1@ through @vN@.

%% \item[Enter a function] (@v1 @@ v2@) -- Enter the closure referred to by @v1@, with
%%   argument @v2@. In other words, function application. Note that @v1@ represents an
%%   \emph{unknown} function -- one for which we compute the address at run-time.

%% \item[Call a block] (@f(v1, ..., vN)@) -- Jump to the block labeled @f@ with the arguments
%%   given. In this case we know the function @f@ refers to and do not need to examine
%%   a closure in order to execute it.
%% \item[Create a value] (@C v1 ... vN@) -- Create a data value with tag @C@, holding
%%   the values found in variables @v1 ... vN@.
%% \end{description}

%% %% TODO: Describe alt syntax.

%% Statements in a block either bind the result of a tail statement 
%% (@v <- tailM@) or branch conditionally (@case v of ... @). Binding ``runs''
%% a computation and ``dereferences'' the result, placing
%% the value in a variable (e.g., @v@). That same variable can be bound
%% again later, but that does not affect previous uses of @v@. In essence, the old
%% name becomes hidden and its value inaccessible.

%% Though the syntax allows multiple @case@ statements in a function
%% body, only one can appear and it must be the last statement in the
%% body. The arms of the @case@ statement can only match on constructor
%% tags (@C@) and can only bind the constructor arguments to variables
%% (@v1 ... vN@). Each arm then jumps to a known block with those
%% variables as arguments. This choice makes compilation simpler.


%% %% \emph{Defines our monadic language and explains the terms in
%% %%   it. Example programs are given which illustrate closure construction
%% %%   and data allocation. The use of ``tail'' vs. statements is motivated
%% %%   and described. }

%% \emph{Need to talk about the monad we work in as well - what 
%% do bind and return mean?}

%% \section{Compiling to Our MIL}
%% \emph{A compilation scheme which uses Hoopls ``shapes'' is
%% described. This scheme will give use our initial, unoptimized
%% MIL program. An example (possibly |compose|, or |const3|) illustrates 
%% our scheme.}

\ifthenelse{\boolean{standaloneFlag}}
           {\bibliography{thesis}}{}

\end{document}
