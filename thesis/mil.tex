\documentclass[12pt]{report}
%include polycode.fmt
\include{preamble}
\begin{document}
\include{document.preamble}

\chapter{A Monadic Intermediate Language}
\label{ref_chapter_mil}

%% What is an intermediate language? What is a ``Monadic'' one?
Most compilers do not generate executable machine code directly from a
program source file. Rather, programs get translated into one or more
\emph{intermediate forms}. The compiler may implement a pipeline of
translations, each translating the program into a more detailed (i.e.,
lower-level) representation. Frequently these intermediate forms are 
also languages, with their own syntax, semantics, type-systems,
and more. 

\section{Three-address Code}

Intermediate forms typically expose more detail about the
implementation of a program, while at the same time making some
optimization or transformation easier or even possible. 
\emph{Three-address code}, one such intermediate form, translates the
program into assembly-language like form, using \emph{registers} to
hold values. Infinitely many registers can be named, making registers
more like memory locations than registers in real hardware. Each
instruction in the translated program has two operand registers and one
destination register, thus the name ``three-address.'' 

Three-address code makes all intermediate expression values explicit, 
by reducing complicated expressions to a series of assignments. 
For example, the expression:
\[a = \frac{(b * c + d)}{2},\]
would be expressed in three-address code as:
\begin{AVerb}
  s = b * c;
  t = s + d;
  a  = t / 2;
\end{AVerb}
where #s# and #t# are new temporaries created by the compiler. This 
representation makes it easier for the compiler to re-order expressions,
unravel complex control-flow, and manipulate intermediate values. 

\section{Monadic Intermediate Language}

Our intermediate language, MIL, serves the same purpose as 
three-address code and other intermediate forms: it exposes
more detail about the implementation of a program, while
making some optimizations simpler or even possible. In contrast to
three-address code, however, our language supports features 
unique to functional languages -- namely, treating functions as
first-class values. 

A MIL program consists of a number of \emph{basic blocks}, sequences
of instructions which execute in order, terminated by a return or
branch. Each sequence ends with a eithe a return (jump back to the
calling block) or a branch to another block (though there may be many
possible choices). Conditional branches are allowed at the end of a
block, where one (of many) destinations can be selected based on some
condition.

To give a sense of MIL, consider the definition of $compose$ given in
Figure \ref{fig_mil1a}. Figure \ref{fig_mil1b} shows a fragment of this 
expression in MIL. The \emph{block declaration}
on line \ref{fig_mil1b_block_decl} gives the name of
the block (#compose#) and arguments that will be passed in (#f#, #g#,
and #x#). Line \ref{fig_mil1b_gofx} applies #g# to #x# and assigns
the result to #t1#. The #@@# operator represents function application. 
Of course, we assume #g# refers to a function (or, more precisely, a 
\emph{closure}). The #<-# operator assigns the result of the operation
on its right-hand side to the locatin on the left. In turn, line 
\ref{fig_mil1b_fofx} applies #f# to #t1# and assigns the result
to #t2#. The last line returns #t2#. Thus, the #compose# block returns
the value of \lamPApp{f}{\lamPApp{g}{x}}, just as in our original \lamA
expression.

\begin{myfig}[t]
  \subfloat[]{$compose = \lamAbs{f}{\lamAbs{g}{\lamAbs{x}{\lamApp{f}{\lamPApp{g}{x}}}}}$%%
      \label{fig_mil1a}}
  \subfloat[]{\input{lst_mil1}\label{fig_mil1b}}
  \caption{\subref{fig_mil1a} gives a \lamA definition of the composition
    function; \subref{fig_mil1b} shows a fragment of the MIL program
    for $compose$.}
  \label{fig_mil1}
\end{myfig}


%% Motivation for MIL

%% Syntax of MIL

%% Compiling the lambda-calculus to MIL

%% \section{Monadic Intermediate Language}

%% %% What does the language support?

%% Our monadic language takes its inspiration from Haskell's @do@
%% notation. It is a pure functional language, making allocation of data
%% structures and closures explicit via monadic syntax. Functions in MIL
%% define computations which, when run, can affect heap memory. Figure
%% \ref{figMILDef} gives the syntax of the language.

%% %% TODO: Mention that v restricts the term to variables
%% %% only.

%% \begin{figure}[h]
%% \begin{code}
%%   defM := k {v1, ..., vN} v = k1 {v1, ..., vN, v} 
%%     | k {v1, ..., vN} v = b(v1, ..., vN, v)
%%     | b(v1, ..., vN) = bodyM
%%     | t <- k {}

%%   bodyM := do 
%%     stmtM1 
%%     ... 
%%     stmtMN 
%%     tailM

%%   stmtM := v <- tailM
%%     | case v of [alt1, ..., altN]


%%   tailM := return v
%%     | v1 @ v2
%%     | k {v1, ..., vN}
%%     | f(v1, ..., vN)
%%     | C v1 ... vN

%%   alt := C v1 ... vN -> b(v1, ..., vM) -- m <= n
%% \end{code}
%% \caption{Concrete syntax for our monadic intermediate language.}
%% \label{figMILDef}
%% \end{figure}

%% MIL programs consist of a series of definitions (@defM@). Each
%% definition can be any of the following.

%% \begin{description}
%%   \item[Closure-capturing] (@k {v1, ..., vN} v = k1 {v1, ..., vN, v}@) -- This function
%%     expects to find the variables @v1, ..., vN@ in its own closure. It constructs
%%     a new closure containing the existing variables plus the newly captured variable
%%     @v@. The new closure refers to @k1@, another closure-capturing function.
%%   \item[Block-calling] (@k {v1, ..., vN} v = b(v1, ..., vN, v)@) -- This function immediately
%%     jumps to block @b@ with arguments @v1, ..., vN@ and @v@. No closure value needs to
%%     be constructed. 
%%   \item[Function block] (@b(v1, ..., vN) = bodyM@) -- This function executes the statements
%%     in the body. 
%%   \item[Top-level] (@t <- k {}@) -- This special case ensures top-level definitions in the program
%%     can be accessed like any other function. The notation indicates that @t@ holds a closure
%%     structure, referring to the definition @k@. 
%% \end{description}

%% Notice that we can distinguish syntatically between functions that
%% merely create a closure (@k { ... }@) and those that do actual work
%% (@b(...)@). The body of a @k@ functin can only allocate another
%% closure or jump to a block. A block, on the other hand, can do other
%% work, but it cannot directly return a closure. As will be described in
%% chapter \ref{ref_chapter_uncurrying} this makes it much easier to
%% recognize and elminate intermediate closures.

%% The body of each block consists of statements followed by a
%% \emph{tail}. Tails can only
%% appear as the last statement in a block or on the right-hand side of
%% the monadic arrow (``@<-@''). Tail instructions, in other words, cause 
%% effects. The three tail statements follow:

%% \begin{description}
%% \item[Return a computation] (@return v@) -- Returns the result of a computation
%%   to the caller.

%% \item[Create a closure] (@k {v1, ..., vN}@) -- Creates a closure pointing to
%%   function @k@, capturing variables @v1@ through @vN@.

%% \item[Enter a function] (@v1 @@ v2@) -- Enter the closure referred to by @v1@, with
%%   argument @v2@. In other words, function application. Note that @v1@ represents an
%%   \emph{unknown} function -- one for which we compute the address at run-time.

%% \item[Call a block] (@f(v1, ..., vN)@) -- Jump to the block labeled @f@ with the arguments
%%   given. In this case we know the function @f@ refers to and do not need to examine
%%   a closure in order to execute it.
%% \item[Create a value] (@C v1 ... vN@) -- Create a data value with tag @C@, holding
%%   the values found in variables @v1 ... vN@.
%% \end{description}

%% %% TODO: Describe alt syntax.

%% Statements in a block either bind the result of a tail statement 
%% (@v <- tailM@) or branch conditionally (@case v of ... @). Binding ``runs''
%% a computation and ``dereferences'' the result, placing
%% the value in a variable (e.g., @v@). That same variable can be bound
%% again later, but that does not affect previous uses of @v@. In essence, the old
%% name becomes hidden and its value inaccessible.

%% Though the syntax allows multiple @case@ statements in a function
%% body, only one can appear and it must be the last statement in the
%% body. The arms of the @case@ statement can only match on constructor
%% tags (@C@) and can only bind the constructor arguments to variables
%% (@v1 ... vN@). Each arm then jumps to a known block with those
%% variables as arguments. This choice makes compilation simpler.


%% %% \emph{Defines our monadic language and explains the terms in
%% %%   it. Example programs are given which illustrate closure construction
%% %%   and data allocation. The use of ``tail'' vs. statements is motivated
%% %%   and described. }

%% \emph{Need to talk about the monad we work in as well - what 
%% do bind and return mean?}

%% \section{Compiling to Our MIL}
%% \emph{A compilation scheme which uses Hoopls ``shapes'' is
%% described. This scheme will give use our initial, unoptimized
%% MIL program. An example (possibly |compose|, or |const3|) illustrates 
%% our scheme.}


\end{document}
